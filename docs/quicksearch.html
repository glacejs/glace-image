<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"config.js.html":{"id":"config.js.html","title":"Source: config.js","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Source: config.js &quot;use strict&quot;; /** * Configures `Image` plugin. Extends `GlaceJS` configuration. * * @namespace GlaceConfig */ var U = require(&quot;glace-utils&quot;); var config = U.config; if (process.platform === &quot;win32&quot;) { require(&quot;binary&quot;).activateImageMagick(); }; module.exports = config; × Search results Close "},"image.js.html":{"id":"image.js.html","title":"Source: image.js","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Source: image.js &quot;use strict&quot;; /** * Creates new instance of Image. * * @class * @name Image * @arg {string} srcPath - path to processed image * @arg {object} [srcOpts] - image options * @arg {number} [srcOpts.scaleX=1] - image current scale value on `X` axis * @arg {number} [srcOpts.scaleY=1] - image current scale value on `Y` axis * @arg {object} [injects] - Dependency injections. * @arg {object} [injects.sharp] - Injected `sharp` module. */ var sharp = require(&quot;sharp&quot;); var temp = require(&quot;temp&quot;); var U = require(&quot;glace-utils&quot;); sharp.cache(false); var Image = function (srcPath, srcOpts, injects) { if (!(this instanceof Image)) return new Image(srcPath, srcOpts); srcOpts = U.defVal(srcOpts, {}); srcOpts.scaleX = U.defVal(srcOpts.scaleX, 1); srcOpts.scaleY = U.defVal(srcOpts.scaleY, 1); this._srcPath = srcPath; this._srcOpts = srcOpts; this._pixelDenominator = 255 * Math.sqrt(3); injects = U.defVal(injects, {}); this.__sharp = U.defVal(injects.sharp, sharp); }; /** * Defines whether processed image is transparent. * * @async * @method * @return {Promise&lt;boolean&gt;} - `true` if image is transparent, `false` * otherwise. */ Image.prototype.isTransparent = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== 0) return false; }; }; return true; }); }; /** * Defines whether processed image is monochrome. * * @async * @method * @return {Promise&lt;boolean&gt;} - `true` if image is monochrome, `false` * otherwise. */ Image.prototype.isMonochrome = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; var firstPixel = pixels[0][0]; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== firstPixel.A || row[x].R !== firstPixel.R || row[x].G !== firstPixel.G || row[x].B !== firstPixel.B) { return false; }; }; }; return true; }); }; /** * Defines whether processed image is black. * * @async * @method * @return {Promise&lt;boolean&gt;} - `true` if image is black, `false` otherwise. */ Image.prototype.isBlack = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== 255 || row[x].R !== 0 || row[x].G !== 0 || row[x].B !== 0) { return false; }; }; }; return true; }); }; /** * Defines whether processed image is white. * * @async * @method * @return {Promise&lt;boolean&gt;} - `true` if image is white, `false` otherwise. */ Image.prototype.isWhite = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== 255 || row[x].R !== 255 || row[x].G !== 255 || row[x].B !== 255) { return false; }; }; }; return true; }); }; /** * Defines if processed image includes specified image. * * @method * @arg {string} dstPath - path to potentially included image * @arg {object} [dstOpts] - included image options * @arg {number} [dstOpts.tolerance=0.05] - comparison tolerance * @arg {?string} [dstOpts.matchedPath=null] - path to same captured place * @arg {boolean} [dstOpts.saveMatch=false] - flag to capture images * intersection or no * @return {Promise&lt;object&gt;} - result */ Image.prototype.includes = function (dstPath, dstOpts) { dstOpts = U.defVal(dstOpts, {}); dstOpts.scaleX = U.defVal(dstOpts.scaleX, 1); dstOpts.scaleY = U.defVal(dstOpts.scaleY, 1); this._dstPath = dstPath; this._dstOpts = dstOpts; this._tolerance = U.defVal(dstOpts.tolerance, .05); this._matchedPath = U.defVal(dstOpts.matchedPath); this._saveMatch = U.defVal(dstOpts.saveMatch, !!this._matchedPath); if (this._saveMatch &amp;&amp; !this._matchedPath) this._matchedPath = temp.path({ suffix: '.png' }); var srcImage; return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { srcImage = image; return this._loadImg(this._dstPath, this._dstOpts); }).then(dstImage =&gt; { return this._includes(srcImage, dstImage); }).then(result =&gt; { if (!result.isIncluded) return { isIncluded: false }; if (!this._saveMatch) return result; return this ._saveMatchImage(result.offsetX, result.offsetY, result.width, result.height) .then(() =&gt; { result.matchedPath = this._matchedPath; return result; }); }); }; /** * Loads image. * * @async * @method * @protected * @arg {string} imgPath - path loaded image * @arg {object} imgOpts - image options * @return {Promise&lt;object&gt;} - image data */ Image.prototype._loadImg = function(imgPath, imgOpts) { var width, height, hasAlpha, channels; var img = this.__sharp(imgPath); return img.metadata().then(metadata =&gt; { hasAlpha = metadata.hasAlpha; channels = metadata.channels; width = Math.ceil(metadata.width / imgOpts.scaleX); height = Math.ceil(metadata.height / imgOpts.scaleY); return img.resize(width, height).raw().toBuffer(); }).then(data =&gt; { return { width: width, height: height, data: data, channels: channels, hasAlpha: hasAlpha }; }); }; /** * Saves matched part of image. * * @async * @method * @protected * @arg {number} left - offset from left image border * @arg {number} top - offset from top image border * @arg {number} width - width of matched part * @arg {number} height - height of matched part * @return {Promise&lt;void&gt;} */ Image.prototype._saveMatchImage = function (left, top, width, height) { return this.__sharp(this._srcPath) .extract({ left: left, top: top, width: width, height: height }) .toFile(this._matchedPath); }; /** * Defines whether one image data includes another. * * @method * @protected * @arg {object} src - source image data * @arg {object} dst - destination image data, which is potentially included * @return {object} - result */ Image.prototype._includes = function (src, dst) { var srcPixels = this._cropPixels(this._getPixels(src)), dstPixels = this._cropPixels(this._getPixels(dst)); var offsetX, offsetY, diffValue, x, y, pixels; var srcWidth = srcPixels[0].length, srcHeight = srcPixels.length, dstWidth = dstPixels[0].length, dstHeight = dstPixels.length; var result = { isIncluded: false, diffValue: null, offsetX: null, offsetY: null, width: dstWidth, height: dstHeight }; var deltaX = srcWidth - dstWidth, deltaY = srcHeight - dstHeight; var dstUsedPixels = this._getUsedPixels(dstPixels); for (offsetY = 0; offsetY &lt;= deltaY; offsetY++) { for (offsetX = 0; offsetX &lt;= deltaX; offsetX++) { diffValue = this._getDiffValue(srcPixels, dstUsedPixels, offsetX, offsetY); if (diffValue === null) continue; if (result.diffValue === null || result.diffValue &gt; diffValue) { result.isIncluded = true; result.diffValue = diffValue; result.offsetX = offsetX; result.offsetY = offsetY; }; if (diffValue === 0 || !this._saveMatch) return result; }; }; return result; }; /** * Gets used pixels. * * @method * @protected * @arg {object[][]} pixels - pixels matrix * @return {object[]} List of used pixels. */ Image.prototype._getUsedPixels = function (pixels) { var usedPixels = [], width = pixels[0].length, height = pixels.length, x, y, row; for (y = 0; y &lt; height; y++) { row = pixels[y]; for (x = 0; x &lt; width; x++) { if (this._isPixelUsed(row[x])) { usedPixels.push({ pixel: row[x], x: x, y: y }); }; }; }; return usedPixels; }; /** * Calculates difference between source pixels and destination pixels. * * @method * @protected * @arg {object[][]} srcPixels - source pixels matrix * @arg {object[][]} dstPixels - destination pixels matrix * @arg {number} offsetX - source left border offset * @arg {number} offsetY - source top border offset * @return {number} - difference value */ Image.prototype._getDiffValue = function (srcPixels, dstPixels, offsetX, offsetY) { var diffPixels = 0, limit = this._tolerance * dstPixels.length, dstPixel, srcPixel, i; for (i = 0; i &lt; dstPixels.length; i++) { dstPixel = dstPixels[i]; srcPixel = srcPixels[offsetY + dstPixel.y][offsetX + dstPixel.x]; if (this._isPixelTolerant(srcPixel, dstPixel.pixel)) continue; diffPixels++; if (diffPixels &gt; limit) return null; }; return diffPixels / dstPixels.length; }; /** * Defines whether pixel should be used for difference calculation or no, * according its alpha value. * * @method * @protected * @arg {object} pixel - pixel * @return {boolean} - `true` if should be, `false` otherwise */ Image.prototype._isPixelUsed = function (pixel) { return (255 - pixel.A) / 255 &lt; this._tolerance; }; /** * Defines whether source pixel is tolerant to destination pixel. * * @method * @protected * @arg {object} srcPixel - source pixel * @arg {object} dstPixel - destination pixel * @return {boolean} - `true` if pixels are tolerant, `false` otherwise */ Image.prototype._isPixelTolerant = function(srcPixel, dstPixel) { var deltaR = srcPixel.R - dstPixel.R, deltaG = srcPixel.G - dstPixel.G, deltaB = srcPixel.B - dstPixel.B; return Math.sqrt(deltaR * deltaR + deltaG * deltaG + deltaB * deltaB) / this._pixelDenominator &lt; this._tolerance; }; /** * Retrieves pixels from image data. * * @method * @protected * @arg {object} img - image data * @return {object[][]} - pixels matrix */ Image.prototype._getPixels = function (img) { var pixels = [], height = img.height, width = img.width * img.channels, x, y, offset; for (y = 0; y &lt; height; y++) { offset = width * y; pixels.push([]); for (var x = 0; x &lt; width; x += img.channels) { pixels[y].push({ R: img.data[offset + x], G: img.data[offset + x + 1], B: img.data[offset + x + 2], A: img.hasAlpha ? img.data[offset + x + 3] : 255, }); }; }; return pixels; }; /** * Crops pixels, removes empty rows and columns. * * @method * @protected * @arg {object[][]} pixels - pixels matrix * @return {object[][]} - cropped pixels matrix */ Image.prototype._cropPixels = function (pixels) { pixels = this._cropTop(pixels); pixels.reverse(); pixels = this._cropTop(pixels); pixels.reverse(); pixels = this._transpose(pixels); pixels = this._cropTop(pixels); pixels.reverse(); pixels = this._cropTop(pixels); pixels.reverse(); return this._transpose(pixels); }; /** * Crops top part of pixels matrix. * * @method * @protected * @arg {object[][]} pixels - pixels matrix * @return {object[][]} - cropped pixels matrix */ Image.prototype._cropTop = function (pixels) { var croppedPixels = [], isTransparent = true, width = pixels[0].length, height = pixels.length, x, y, pixelsRow; for (y = 0; y &lt; height; y++) { pixelsRow = pixels[y]; if (isTransparent) { for (x = 0; x &lt; width; x++) { if (pixelsRow[x].A !== 0) { isTransparent = false; break; }; }; }; if (!isTransparent) croppedPixels.push(pixelsRow); }; return croppedPixels; }; /** * Transposes pixels matrix. * * @method * @arg {object[][]} pixels - pixels matrix * @return {object[][]} transposed pixels matrix */ Image.prototype._transpose = function (pixels) { var width = pixels[0].length, height = pixels.length, tPixels = [], x, y; if (width === 0 || height === 0) return []; for (y = 0; y &lt; width; y++) { tPixels[y] = []; for (x = 0; x &lt; height; x++) { tPixels[y][x] = pixels[x][y]; }; }; return tPixels; }; module.exports = Image; × Search results Close "},"steps.js.html":{"id":"steps.js.html","title":"Source: steps.js","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Source: steps.js &quot;use strict&quot;; /** * Steps to manage screenshots and images. * * @mixin ImageSteps */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var _ = require(&quot;lodash&quot;); var imageDiff = require(&quot;image-diff&quot;); var screenshot = require(&quot;desktop-screenshot&quot;); var sharp = require(&quot;sharp&quot;); var uuid = require(&quot;uuid/v4&quot;); var U = require(&quot;glace-utils&quot;); var image = require(&quot;./image&quot;); sharp.cache(false); var ImageSteps = { /** * modules */ __fs: fs, __screenshot: screenshot, __sharp: sharp, /** * Step to make web screenshot in browser. * * @async * @method * @instance * @arg {object} [opts] - Step options. * @arg {string} [opts.imageName] - Screenshot name. File extension * `.png` will be added automatically. Default value is dynamically * generated on each call with algorithm `uuid`. * @arg {string} [opts.imageDirPath] - Screenshot folder path. * @arg {boolean} [opts.by=selenium] - Screenshot variant. Supported * values are &quot;selenium&quot;, &quot;html2canvas&quot;, &quot;system&quot;. * @arg {?string} [opts.cssSelector=null] - CSS selector of DOM element * which of screenshot should be made. * @arg {?string} [opts.backColor=null] - Background color for html2canvas. * Transparent by default. * @arg {?function} [opts.preHook=null] - Function which will be called * in `Steps` context in the beginning of step. * @arg {?function} [opts.postHook=null] - Function which will be called * in `Steps` context at the end of step. * @arg {?string} [opts.element=null] - Web element name which should be * screenshotted. * @arg {boolean} [opts.check=true] - Flag to check screenshot is saved * or no. * @return {Promise&lt;string&gt;} - Path to saved screenshot. * @throws {AssertionError} - If screenshot isn't saved. */ makeScreenshot: async function (opts) { opts = U.defVal(opts, {}); var imageName = U.defVal(opts.imageName, uuid()); imageName = U.toKebab(imageName); if (!imageName.endsWith(&quot;.png&quot;)) imageName += &quot;.png&quot;; var imagePath = U.mkpath( U.defVal(opts.imageDirPath, getScreensDir()), imageName); var by = U.defVal(opts.by, &quot;selenium&quot;); var cssSelector = U.defVal(opts.cssSelector); var backColor = U.defVal(opts.backColor); var preHook = U.defVal(opts.preHook); var postHook = U.defVal(opts.postHook); var element = U.defVal(opts.element); var check = U.defVal(opts.check, true); expect([&quot;selenium&quot;, &quot;html2canvas&quot;, &quot;system&quot;]).to.include(by); if (preHook) await preHook.call(this); if (by === &quot;selenium&quot;) { await this._seleniumScreenshot(imagePath); }; if (by === &quot;html2canvas&quot;) { await this._canvasScreenshot( imagePath, { cssSelector: cssSelector, backColor: backColor }); }; if (by === &quot;system&quot;) { await this._displayScreenshot(imagePath); }; if (element) { await this._cutElement(imagePath, element, { path: imagePath }); }; if (check) { expect(fs.existsSync(imagePath), `Screenshot isn't saved to '${imagePath}'`).to.be.true; expect(await image(imagePath).isTransparent(), `Screenshot '${imagePath}' has empty content`).to.be.false; }; if (postHook) await postHook.call(this); CONF.curTestCase.addScreenshot(imagePath); return imagePath; }, /** * Step to check two image are equal or not equal * * @async * @method * @instance * @arg {string} actualImage - Path to actual image. * @arg {string} expectedImage - Path to expected image. * @arg {object} [opts] - Helper options. * @arg {number} [opts.threshold=0.05] - Threshold of divergence. * @arg {boolean} [opts.shouldBe=true] - Flag to check whether * image are equal or not equal. * @arg {string[]} [opts.elements=[]] - List of elements on image which * should be verified. * @return {Promise&lt;void&gt;} * @throws {AssertionError} - If result of images comparison don't pass * requested parameters. */ checkImagesEquivalence: async function (actualImage, expectedImage, opts) { opts = U.defVal(opts, {}); var elements = U.defVal(opts.elements, []); await this._checkImagesEquivalence(actualImage, expectedImage, opts); for (var element of elements) { var actualElImage = await this._cutElement( actualImage, element, { name: `actual ${element}` }); var expectedElImage = await this._cutElement( expectedImage, element, { name: `expected ${element}` }); await this._checkImagesEquivalence( actualElImage, expectedElImage, opts); }; }, /** * Step to check one image includes or doesn't include another image. * * @async * @method * @instance * @arg {string} fullImage - Path to image which may include. * @arg {string} includedImage - Path to image which may be included. * @arg {object} [opts] - Step options. * @arg {object} [opts.matchedDirPath] - Folder path to save matched image. * @arg {number} [opts.threshold=0.05] - Threshold of divergence. * @arg {boolean} [opts.shouldBe=true] - Flag to check whether * image are equal or not equal. * @return {Promise&lt;void&gt;} */ checkImageInclusion: async function (fullImage, includedImage, opts) { opts = U.defVal(opts, {}); var threshold = U.defVal(opts.threshold, 0.05); var shouldBe = U.defVal(opts.shouldBe, true); var matchedImagePath = U.mkpath( U.defVal( opts.matchedDirPath, path.resolve(getScreensDir(), &quot;inclusions&quot;)), uuid() + &quot;.png&quot;); var errMsg = &quot;Image &quot; + fullImage + &quot; doesn't contain image &quot; + includedImage; var result = await image(fullImage) .includes(includedImage, { tolerance: threshold, matchedPath: matchedImagePath }); if (shouldBe) { expect(result.isIncluded, `Image ${fullImage} doesn't include ${includedImage}`) .be.true; } else { expect(result.isIncluded, `Image ${fullImage} includes image ${includedImage}`) .be.false; }; }, /** * Step to check or make web screenshot in browser. * * @async * @method * @instance * @arg {string} imageName - Screenshot name. File extension * `.png` will be added automatically. * @arg {object} [opts] - Step options. * @arg {string} [opts.imageDirPath] - Screenshot folder path. * @arg {string} [opts.expectedDirPath] - Expected screenshot path. * @arg {boolean} [opts.bySelenium=true] - Flag to use selenium to make * screenshot. Other library `html2canvas` will be used. * @arg {?function} [opts.preHook=null] - Function which will be called * in `Steps` context in the beginning of step. * @arg {?function} [opts.postHook=null] - Function which will be called * in `Steps` context at the end of step. * @arg {string[]} [opts.elements=[]] - List of elements on image which * should be verified. * @arg {boolean} [opts.check=true] - Flag to check screenshot is saved * or no. * @return {Promise&lt;void&gt;} * @throws {AssertionError} - If screenshot isn't saved. */ checkOrMakeScreenshot: async function (imageName, opts) { imageName = U.toKebab(imageName); opts = U.defVal(opts, {}); opts.imageName = imageName; var actualImage = await this.makeScreenshot(opts); if (CONF.compareImages) { testName = CONF.curTestCase ? U.toKebab(CONF.curTestCase.name) : &quot;&quot;; var expectedImage = path.resolve( U.defVal( opts.expectedDirPath, path.resolve(CONF.resourcesDir, testName, &quot;screenshots&quot;)), imageName + &quot;.png&quot;); await this.checkImagesEquivalence( actualImage, expectedImage, opts); }; }, /** * Helper to check two images are equal or not equal. * * @async * @method * @protected * @instance * @arg {string} actualImage - Path to actual image. * @arg {string} expectedImage - Path to expected image. * @arg {object} [opts] - Helper options. * @arg {string} [opts.diffDirPath] - Path to diffs folder. * @arg {number} [opts.threshold=0.05] - Threshold of divergence. * @arg {boolean} [opts.shouldBe=true] - Flag to check whether * image are equal or not equal. * @return {Promise&lt;void&gt;} * @throws {AssertionError} - If actual image doesn't exist. * @throws {AssertionError} - If expected image doesn't exist. * @throws {AssertionError} - If result of images comparison don't pass * requested parameters. */ _checkImagesEquivalence: async function (actualImage, expectedImage, opts) { expect(fs.existsSync(actualImage), `Actual image '${actualImage}' doesn't exist`) .to.be.true; expect(fs.existsSync(expectedImage), `Expected image '${expectedImage}' doesn't exist`) .to.be.true; opts = U.defVal(opts, {}); var threshold = U.defVal(opts.threshold, 0.05); var shouldBe = U.defVal(opts.shouldBe, true); var diffImage = U.mkpath( U.defVal( opts.diffDirPath, path.resolve(getScreensDir(), &quot;diffs&quot;)), uuid() + &quot;.png&quot;); var percentage = (await new Promise((resolve, reject) =&gt; { imageDiff.getFullResult({ actualImage: actualImage, expectedImage: expectedImage, diffImage: diffImage }, function(err, result) { if (err) reject(err); resolve(result); }); })).percentage; if (shouldBe) { expect(percentage, &quot;Images are not equal&quot;).be.lte(threshold); } else { expect(percentage, &quot;Images are equal&quot;).be.gte(threshold); }; }, /** * Helper to make screenshot of display. * * @async * @method * @protected * @instance * @arg {string} imagePath - Path to screenshot which will be saved. * @return {Promise&lt;void&gt;} */ _displayScreenshot: async function (imagePath) { await new Promise((resolve, reject) =&gt; { this.__screenshot(imagePath, err =&gt; { if (err) return reject(err); resolve(); }); }); }, /** * Helper to make screenshot with selenium. * * @async * @method * @protected * @instance * @arg {string} imagePath - Path to screenshot which will be saved. * @return {Promise&lt;void&gt;} */ _seleniumScreenshot: async function (imagePath) { await this.webdriver.saveScreenshot(imagePath); }, /** * Helper to make screenshot with html2canvas. * * @async * @method * @protected * @instance * @arg {string} imagePath - Path to screenshot which will be saved. * @arg {object} [opts] - Helper options. * @arg {?string} [opts.cssSelector=null] - CSS selector of DOM element * which of screenshot should be made. * @arg {?string} [opts.backColor=null] - Background color, transparent by * default. * @arg {number} [opts.timeout=30000] - Time to wait for screenshot is * rendered, ms * @return {Promise&lt;void&gt;} * @throws {Error} - If screenshot will not be rendered during timeout. */ _canvasScreenshot: async function (imagePath, opts) { opts = U.defVal(opts, {}); var cssSelector = U.defVal(opts.cssSelector); var backColor = U.defVal(opts.backColor); var timeout = U.defVal(opts.timeout, 30000); var errMsg = &quot;Can't make screenshot&quot;; if (cssSelector) errMsg += &quot; of element with selector &quot; + cssSelector; await this.webdriver.execute(function (cssSelector, backColor) { function makeScreenshot () { if (cssSelector) { var element = document.querySelector(cssSelector); } else { var element = document.body; }; html2canvas( element, { backgroundColor: backColor, useCORS: true // capture images from another domains }).then(function (canvas) { window.__screenshot = canvas .toDataURL() .split(&quot;data:image/png;base64,&quot;)[1]; }); }; if (typeof(html2canvas) !== &quot;undefined&quot;) { makeScreenshot(); return; }; var script = document.createElement(&quot;script&quot;); script.onload = makeScreenshot; script.src = &quot;http://html2canvas.hertzen.com/dist/html2canvas.min.js&quot;; document.body.appendChild(script); }, cssSelector, backColor); var screenBase64 = await this.webdriver.waitUntil(async () =&gt; { return (await this.webdriver.execute(function () { if (window.__screenshot) { var result = window.__screenshot; delete window.__screenshot; return result; } else { return false; }; })).value; }, timeout, errMsg); fs.writeFileSync(imagePath, screenBase64, &quot;base64&quot;); }, /** * Helper to cut element from image. * * @async * @method * @protected * @instance * @arg {string} imagePath - Path to image which element will be cut from. * @arg {string} elementName - Name of element which will be cut. * @arg {object} [opts] - Helper options. * @arg {string} [opts.path] - Path to cut image. * @arg {string} [opts.dirPath] - Folder path to cut image. * @arg {string} [opts.name] - Name of cut image with element. * @return {Promise&lt;string&gt;} - Path to cut image. * @throws {AssertionError} - If original image doesn't exist. * @throws {AssertionError} - If DOM element is not registered in config. * @throws {AssertionError} - If cut image is not saved. */ _cutElement: async function (imagePath, elementName, opts) { expect(this.__fs.existsSync(imagePath), `Image ${imagePath} doesn't exist`).be.true; var eLoc = await this.__getElementLocation(elementName, imagePath); opts = U.defVal(opts, {}); var targetName = U.toKebab(U.defVal(opts.name, uuid())); if (!targetName.endsWith(&quot;.png&quot;)) targetName += &quot;.png&quot;; var targetPath = U.mkpath( U.defVal( opts.path, path.resolve( U.defVal(opts.dirPath, path.resolve(getScreensDir(), &quot;cut-elements&quot;)), targetName))); if (imagePath === targetPath) { this.__fs.renameSync(imagePath, imagePath + &quot;.tmp&quot;); imagePath += &quot;.tmp&quot;; }; await new Promise((resolve, reject) =&gt; { this.__sharp(imagePath) .extract({ left: eLoc.x, top: eLoc.y, width: eLoc.width, height: eLoc.height }) .crop(sharp.strategy.entropy) .toFile(targetPath, err =&gt; { if (err) reject(err); resolve(); }); }); expect(this.__fs.existsSync(targetPath, `Image ${targetPath} isn't saved`)).be.true; if (imagePath.endsWith(&quot;.tmp&quot;)) this.__fs.unlinkSync(imagePath); return targetPath; }, /** * Helper to get element location. * * @ignore * @async * @method * @private * @instance * @arg {string} name - Element name. * @arg {string} imagePath - Path to image. * @return {object} - Dict with `x`, `y`, `width`, `height` keys. */ __getElementLocation: async function (name, imagePath) { var element = await this.getElement(name); var imageInfo = await new Promise((resolve, reject) =&gt; { this.__sharp(imagePath).toBuffer((err, outputBuffer, info) =&gt; { if (err) reject(err); resolve(info); }); }); imageInfo.x = 0; imageInfo.y = 0; var eLoc = await element.location(); return U.objOnScreenPos(eLoc, imageInfo); }, }; module.exports = ImageSteps; /** * Helper to get screenshots folder. * * @ignore * @function */ var getScreensDir = () =&gt; { var testName = CONF.curTestCase ? U.toKebab(CONF.curTestCase.name) : &quot;&quot;; return path.resolve(CONF.reportsDir, testName, &quot;screenshots&quot;); }; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Source: index.js &quot;use strict&quot;; /** * `GlaceJS Image` plugin. * * @module */ var config, Steps; Object.defineProperties(exports, { /** * @type {GlaceConfig} */ config: { get: function() { config = config || require(&quot;./config&quot;); return config; }, }, /** * @type {ImageSteps} */ Steps: { get: function() { Steps = Steps || require(&quot;./steps&quot;); return Steps; }, }, }); × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Modules Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Classes Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Namespaces Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Mixins Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Tutorials Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes | Source Code | Release Notes GlaceJS Image pluginProvides steps for GlaceJS framework to process images and screenshots. Features Image capture via selenium Image capture via html2canvas Image capture via system screenshot Images comparision mechanism via ImageMagick Search image inside image via own pixel-by-pixel algorithm How to installnpm i glace-imageHow to usevar glaceImage = require(&quot;glace-image&quot;); glaceImage.Steps; glaceImage.config;If plugin is used as a part of GlaceJS it will be loaded automatically. API config steps Test examplesSee integration tests in order to explore examples. × Search results Close "},"GlaceConfig.html":{"id":"GlaceConfig.html","title":"Namespace: GlaceConfig","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Namespace: GlaceConfig GlaceConfig Configures Image plugin. Extends GlaceJS configuration. Source: config.js, line 2 × Search results Close "},"Image.html":{"id":"Image.html","title":"Class: Image","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Class: Image Image new Image(srcPath [, srcOpts] [, injects]) Creates new instance of Image. Parameters: Name Type Argument Description srcPath string path to processed image srcOpts object &lt;optional&gt; image options Properties Name Type Argument Default Description scaleX number &lt;optional&gt; 1 image current scale value on X axis scaleY number &lt;optional&gt; 1 image current scale value on Y axis injects object &lt;optional&gt; Dependency injections. Properties Name Type Argument Description sharp object &lt;optional&gt; Injected sharp module. Source: image.js, line 2 Methods &lt;protected&gt; _cropPixels(pixels) Crops pixels, removes empty rows and columns. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 419 Returns: cropped pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; &lt;protected&gt; _cropTop(pixels) Crops top part of pixels matrix. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 440 Returns: cropped pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; &lt;protected&gt; _getDiffValue(srcPixels, dstPixels, offsetX, offsetY) Calculates difference between source pixels and destination pixels. Parameters: Name Type Description srcPixels Array.&lt;Array.&lt;object&gt;&gt; source pixels matrix dstPixels Array.&lt;Array.&lt;object&gt;&gt; destination pixels matrix offsetX number source left border offset offsetY number source top border offset Source: image.js, line 331 Returns: difference value Type number &lt;protected&gt; _getPixels(img) Retrieves pixels from image data. Parameters: Name Type Description img object image data Source: image.js, line 390 Returns: pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; &lt;protected&gt; _getUsedPixels(pixels) Gets used pixels. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 300 Returns: List of used pixels. Type Array.&lt;object&gt; &lt;protected&gt; _includes(src, dst) Defines whether one image data includes another. Parameters: Name Type Description src object source image data dst object destination image data, which is potentially included Source: image.js, line 250 Returns: result Type object &lt;protected&gt; _isPixelTolerant(srcPixel, dstPixel) Defines whether source pixel is tolerant to destination pixel. Parameters: Name Type Description srcPixel object source pixel dstPixel object destination pixel Source: image.js, line 372 Returns: true if pixels are tolerant, false otherwise Type boolean &lt;protected&gt; _isPixelUsed(pixel) Defines whether pixel should be used for difference calculation or no, according its alpha value. Parameters: Name Type Description pixel object pixel Source: image.js, line 360 Returns: true if should be, false otherwise Type boolean &lt;async, protected&gt; _loadImg(imgPath, imgOpts) Loads image. Parameters: Name Type Description imgPath string path loaded image imgOpts object image options Source: image.js, line 207 Returns: image data Type Promise.&lt;object&gt; &lt;async, protected&gt; _saveMatchImage(left, top, width, height) Saves matched part of image. Parameters: Name Type Description left number offset from left image border top number offset from top image border width number width of matched part height number height of matched part Source: image.js, line 236 Returns: Type Promise.&lt;void&gt; _transpose(pixels) Transposes pixels matrix. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 472 Returns: transposed pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; includes(dstPath [, dstOpts]) Defines if processed image includes specified image. Parameters: Name Type Argument Description dstPath string path to potentially included image dstOpts object &lt;optional&gt; included image options Properties Name Type Argument Default Description tolerance number &lt;optional&gt; 0.05 comparison tolerance matchedPath string &lt;optional&gt; &lt;nullable&gt; null path to same captured place saveMatch boolean &lt;optional&gt; false flag to capture images intersection or no Source: image.js, line 161 Returns: result Type Promise.&lt;object&gt; &lt;async&gt; isBlack() Defines whether processed image is black. Source: image.js, line 100 Returns: true if image is black, false otherwise. Type Promise.&lt;boolean&gt; &lt;async&gt; isMonochrome() Defines whether processed image is monochrome. Source: image.js, line 70 Returns: true if image is monochrome, false otherwise. Type Promise.&lt;boolean&gt; &lt;async&gt; isTransparent() Defines whether processed image is transparent. Source: image.js, line 46 Returns: true if image is transparent, false otherwise. Type Promise.&lt;boolean&gt; &lt;async&gt; isWhite() Defines whether processed image is white. Source: image.js, line 128 Returns: true if image is white, false otherwise. Type Promise.&lt;boolean&gt; × Search results Close "},"ImageSteps.html":{"id":"ImageSteps.html","title":"Mixin: ImageSteps","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Mixin: ImageSteps ImageSteps Steps to manage screenshots and images. Source: steps.js, line 2 Members &lt;static&gt; __fs modules Source: steps.js, line 26 Methods &lt;async, protected&gt; _canvasScreenshot(imagePath [, opts]) Helper to make screenshot with html2canvas. Parameters: Name Type Argument Description imagePath string Path to screenshot which will be saved. opts object &lt;optional&gt; Helper options. Properties Name Type Argument Default Description cssSelector string &lt;optional&gt; &lt;nullable&gt; null CSS selector of DOM element which of screenshot should be made. backColor string &lt;optional&gt; &lt;nullable&gt; null Background color, transparent by default. timeout number &lt;optional&gt; 30000 Time to wait for screenshot is rendered, ms Source: steps.js, line 339 Throws: If screenshot will not be rendered during timeout. Type Error Returns: Type Promise.&lt;void&gt; &lt;async, protected&gt; _checkImagesEquivalence(actualImage, expectedImage [, opts]) Helper to check two images are equal or not equal. Parameters: Name Type Argument Description actualImage string Path to actual image. expectedImage string Path to expected image. opts object &lt;optional&gt; Helper options. Properties Name Type Argument Default Description diffDirPath string &lt;optional&gt; Path to diffs folder. threshold number &lt;optional&gt; 0.05 Threshold of divergence. shouldBe boolean &lt;optional&gt; true Flag to check whether image are equal or not equal. Source: steps.js, line 249 Throws: If actual image doesn't exist. Type AssertionError If expected image doesn't exist. Type AssertionError If result of images comparison don't pass requested parameters. Type AssertionError Returns: Type Promise.&lt;void&gt; &lt;async, protected&gt; _cutElement(imagePath, elementName [, opts]) Helper to cut element from image. Parameters: Name Type Argument Description imagePath string Path to image which element will be cut from. elementName string Name of element which will be cut. opts object &lt;optional&gt; Helper options. Properties Name Type Argument Description path string &lt;optional&gt; Path to cut image. dirPath string &lt;optional&gt; Folder path to cut image. name string &lt;optional&gt; Name of cut image with element. Source: steps.js, line 417 Throws: If original image doesn't exist. Type AssertionError If DOM element is not registered in config. Type AssertionError If cut image is not saved. Type AssertionError Returns: Path to cut image. Type Promise.&lt;string&gt; &lt;async, protected&gt; _displayScreenshot(imagePath) Helper to make screenshot of display. Parameters: Name Type Description imagePath string Path to screenshot which will be saved. Source: steps.js, line 300 Returns: Type Promise.&lt;void&gt; &lt;async, protected&gt; _seleniumScreenshot(imagePath) Helper to make screenshot with selenium. Parameters: Name Type Description imagePath string Path to screenshot which will be saved. Source: steps.js, line 318 Returns: Type Promise.&lt;void&gt; &lt;async&gt; checkImageInclusion(fullImage, includedImage [, opts]) Step to check one image includes or doesn't include another image. Parameters: Name Type Argument Description fullImage string Path to image which may include. includedImage string Path to image which may be included. opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description matchedDirPath object &lt;optional&gt; Folder path to save matched image. threshold number &lt;optional&gt; 0.05 Threshold of divergence. shouldBe boolean &lt;optional&gt; true Flag to check whether image are equal or not equal. Source: steps.js, line 156 Returns: Type Promise.&lt;void&gt; &lt;async&gt; checkImagesEquivalence(actualImage, expectedImage [, opts]) Step to check two image are equal or not equal Parameters: Name Type Argument Description actualImage string Path to actual image. expectedImage string Path to expected image. opts object &lt;optional&gt; Helper options. Properties Name Type Argument Default Description threshold number &lt;optional&gt; 0.05 Threshold of divergence. shouldBe boolean &lt;optional&gt; true Flag to check whether image are equal or not equal. elements Array.&lt;string&gt; &lt;optional&gt; [] List of elements on image which should be verified. Source: steps.js, line 127 Throws: If result of images comparison don't pass requested parameters. Type AssertionError Returns: Type Promise.&lt;void&gt; &lt;async&gt; checkOrMakeScreenshot(imageName [, opts]) Step to check or make web screenshot in browser. Parameters: Name Type Argument Description imageName string Screenshot name. File extension .png will be added automatically. opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description imageDirPath string &lt;optional&gt; Screenshot folder path. expectedDirPath string &lt;optional&gt; Expected screenshot path. bySelenium boolean &lt;optional&gt; true Flag to use selenium to make screenshot. Other library html2canvas will be used. preHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context in the beginning of step. postHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context at the end of step. elements Array.&lt;string&gt; &lt;optional&gt; [] List of elements on image which should be verified. check boolean &lt;optional&gt; true Flag to check screenshot is saved or no. Source: steps.js, line 209 Throws: If screenshot isn't saved. Type AssertionError Returns: Type Promise.&lt;void&gt; &lt;async&gt; makeScreenshot( [opts]) Step to make web screenshot in browser. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description imageName string &lt;optional&gt; Screenshot name. File extension .png will be added automatically. Default value is dynamically generated on each call with algorithm uuid. imageDirPath string &lt;optional&gt; Screenshot folder path. by boolean &lt;optional&gt; selenium Screenshot variant. Supported values are &quot;selenium&quot;, &quot;html2canvas&quot;, &quot;system&quot;. cssSelector string &lt;optional&gt; &lt;nullable&gt; null CSS selector of DOM element which of screenshot should be made. backColor string &lt;optional&gt; &lt;nullable&gt; null Background color for html2canvas. Transparent by default. preHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context in the beginning of step. postHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context at the end of step. element string &lt;optional&gt; &lt;nullable&gt; null Web element name which should be screenshotted. check boolean &lt;optional&gt; true Flag to check screenshot is saved or no. Source: steps.js, line 57 Throws: If screenshot isn't saved. Type AssertionError Returns: Path to saved screenshot. Type Promise.&lt;string&gt; × Search results Close "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Module: index GlaceJS Image plugin. Source: index.js, line 2 Members &lt;inner&gt; config :GlaceConfig Type: GlaceConfig Source: index.js, line 14 &lt;inner&gt; Steps :ImageSteps Type: ImageSteps Source: index.js, line 23 × Search results Close "},"tutorial-release-notes.html":{"id":"tutorial-release-notes.html","title":"Tutorial: Release Notes","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Tutorials Release Notes Release Notes v1.0.7 Support background color for html2canvas in steps. v1.0.6 Updated html2canvas. Fixed bug that element screenshot didn't replace browser screenshot. Added option to pass image path in method to cut element. v1.0.5 Fixes according to unit tests results. Dependencies updating. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
