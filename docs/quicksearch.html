<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"config.js.html":{"id":"config.js.html","title":"Source: config.js","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Source: config.js &quot;use strict&quot;; /** * Configures `Image` plugin. Extends `GlaceJS` configuration. * * @namespace GlaceConfig */ var U = require(&quot;glace-utils&quot;); var config = U.config; var args = config.args; config.image = U.defVal(config.image, {}); config.image.screenOnFail = args.screenshotOnFail; module.exports = config; × Search results Close "},"image.js.html":{"id":"image.js.html","title":"Source: image.js","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Source: image.js &quot;use strict&quot;; /** * Creates new instance of Image. * * @class * @name Image * @arg {string} srcPath - path to processed image * @arg {object} [srcOpts] - image options * @arg {number} [srcOpts.scaleX=1] - image current scale value on `X` axis * @arg {number} [srcOpts.scaleY=1] - image current scale value on `Y` axis * @arg {object} [injects] - Dependency injections. * @arg {object} [injects.sharp] - Injected `sharp` module. */ var fs = require(&quot;fs&quot;); var _ = require(&quot;lodash&quot;); var pixelmatch = require(&quot;pixelmatch&quot;); var PNG = require(&quot;pngjs&quot;).PNG; var sharp = require(&quot;sharp&quot;); var temp = require(&quot;temp&quot;).track(); var U = require(&quot;glace-utils&quot;); sharp.cache(false); var Image = function (srcPath, srcOpts, injects) { if (!(this instanceof Image)) return new Image(srcPath, srcOpts); srcOpts = U.defVal(srcOpts, {}); srcOpts.scaleX = U.defVal(srcOpts.scaleX, 1); srcOpts.scaleY = U.defVal(srcOpts.scaleY, 1); this._srcPath = srcPath; this._srcOpts = srcOpts; this._pixelDenominator = 255 * Math.sqrt(3); injects = U.defVal(injects, {}); this.__sharp = U.defVal(injects.sharp, sharp); }; /** * Defines whether processed image is transparent. * * @async * @method * @return {Promise&lt;boolean&gt;} - `true` if image is transparent, `false` * otherwise. */ Image.prototype.isTransparent = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== 0) return false; }; }; return true; }); }; /** * Defines whether processed image is monochrome. * * @async * @method * @return {Promise&lt;boolean&gt;} - `true` if image is monochrome, `false` * otherwise. */ Image.prototype.isMonochrome = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; var firstPixel = pixels[0][0]; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== firstPixel.A || row[x].R !== firstPixel.R || row[x].G !== firstPixel.G || row[x].B !== firstPixel.B) { return false; }; }; }; return true; }); }; /** * Defines whether processed image is black. * * @async * @method * @return {Promise&lt;boolean&gt;} - `true` if image is black, `false` otherwise. */ Image.prototype.isBlack = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== 255 || row[x].R !== 0 || row[x].G !== 0 || row[x].B !== 0) { return false; }; }; }; return true; }); }; /** * Defines whether processed image is white. * * @async * @method * @return {Promise&lt;boolean&gt;} - `true` if image is white, `false` otherwise. */ Image.prototype.isWhite = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== 255 || row[x].R !== 255 || row[x].G !== 255 || row[x].B !== 255) { return false; }; }; }; return true; }); }; /** * Defines if processed image includes specified image. * * @method * @arg {string} dstPath - path to potentially included image * @arg {object} [dstOpts] - included image options * @arg {number} [dstOpts.tolerance=0.05] - comparison tolerance * @arg {?string} [dstOpts.matchedPath=null] - path to same captured place * @arg {boolean} [dstOpts.saveMatch=false] - flag to capture images * intersection or no * @return {Promise&lt;object&gt;} - result */ Image.prototype.includes = function (dstPath, dstOpts) { dstOpts = U.defVal(dstOpts, {}); dstOpts.scaleX = U.defVal(dstOpts.scaleX, 1); dstOpts.scaleY = U.defVal(dstOpts.scaleY, 1); this._dstPath = dstPath; this._dstOpts = dstOpts; this._tolerance = U.defVal(dstOpts.tolerance, .05); this._matchedPath = U.defVal(dstOpts.matchedPath); this._saveMatch = U.defVal(dstOpts.saveMatch, !!this._matchedPath); if (this._saveMatch &amp;&amp; !this._matchedPath) this._matchedPath = temp.path({ suffix: &quot;.png&quot; }); var srcImage; return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { srcImage = image; return this._loadImg(this._dstPath, this._dstOpts); }).then(dstImage =&gt; { return this._includes(srcImage, dstImage); }).then(result =&gt; { if (!result.isIncluded) return { isIncluded: false }; if (!this._saveMatch) return result; return this ._saveMatchImage(result.offsetX, result.offsetY, result.width, result.height) .then(() =&gt; { result.matchedPath = this._matchedPath; return result; }); }); }; /** * Defines if processed image equal to specified image. * * @method * @arg {string} dstPath - path to potentially equal image * @arg {object} [dstOpts] - included image options * @arg {number} [dstOpts.tolerance=0.05] - comparison tolerance * @arg {?string} [dstOpts.diffPath=null] - path to save captured difference. * @arg {boolean} [dstOpts.saveDiff=false] - flag to capture images * intersection or no * @return {Promise&lt;number&gt;} Ratio of difference. */ Image.prototype.equalTo = function (dstPath, dstOpts) { dstOpts = U.defVal(dstOpts, {}); dstOpts.scaleX = U.defVal(dstOpts.scaleX, 1); dstOpts.scaleY = U.defVal(dstOpts.scaleY, 1); var tolerance = U.defVal(dstOpts.tolerance, .05); var diffPath = U.defVal(dstOpts.diffPath); var saveDiff = U.defVal(dstOpts.saveDiff, !!diffPath); if (saveDiff &amp;&amp; !diffPath) { diffPath = temp.path({ suffix: &quot;.png&quot; }); } var srcImage; return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { srcImage = image; return this._loadImg(dstPath, dstOpts); }).then(dstImage =&gt; { var diffImage, diffData = null; if (diffPath) { diffImage = new PNG({ width: srcImage.width, height: srcImage.height }); diffData = diffImage.data; }; var diffPixels = pixelmatch( srcImage.data, dstImage.data, diffData, srcImage.width, srcImage.height, { threshold: tolerance }); var diff = _.round(diffPixels / (srcImage.width * srcImage.height), 2); if (diffImage) { return new Promise((resolve, reject) =&gt; { var stream = fs.createWriteStream(diffPath); stream.on(&quot;finish&quot;, () =&gt; stream.close(() =&gt; resolve(diff))); stream.on(&quot;error&quot;, reject); diffImage.pack().pipe(stream); }); } else { return diff; } }); }; /** * Loads image. * * @async * @method * @protected * @arg {string} imgPath - path loaded image * @arg {object} imgOpts - image options * @return {Promise&lt;object&gt;} - image data */ Image.prototype._loadImg = function(imgPath, imgOpts) { var width, height, hasAlpha, channels; var img = this.__sharp(imgPath); return img.metadata().then(metadata =&gt; { hasAlpha = metadata.hasAlpha; channels = metadata.channels; width = Math.ceil(metadata.width / imgOpts.scaleX); height = Math.ceil(metadata.height / imgOpts.scaleY); return img.resize(width, height).raw().toBuffer(); }).then(data =&gt; { return { width: width, height: height, data: data, channels: channels, hasAlpha: hasAlpha }; }); }; /** * Saves matched part of image. * * @async * @method * @protected * @arg {number} left - offset from left image border * @arg {number} top - offset from top image border * @arg {number} width - width of matched part * @arg {number} height - height of matched part * @return {Promise&lt;void&gt;} */ Image.prototype._saveMatchImage = function (left, top, width, height) { return this.__sharp(this._srcPath) .extract({ left: left, top: top, width: width, height: height }) .toFile(this._matchedPath); }; /** * Defines whether one image data includes another. * * @method * @protected * @arg {object} src - source image data * @arg {object} dst - destination image data, which is potentially included * @return {object} - result */ Image.prototype._includes = function (src, dst) { var srcPixels = this._cropPixels(this._getPixels(src)), dstPixels = this._cropPixels(this._getPixels(dst)); var offsetX, offsetY, diffValue; var srcWidth = srcPixels[0].length, srcHeight = srcPixels.length, dstWidth = dstPixels[0].length, dstHeight = dstPixels.length; var result = { isIncluded: false, diffValue: null, offsetX: null, offsetY: null, width: dstWidth, height: dstHeight }; var deltaX = srcWidth - dstWidth, deltaY = srcHeight - dstHeight; var dstUsedPixels = this._getUsedPixels(dstPixels); for (offsetY = 0; offsetY &lt;= deltaY; offsetY++) { for (offsetX = 0; offsetX &lt;= deltaX; offsetX++) { diffValue = this._getDiffValue(srcPixels, dstUsedPixels, offsetX, offsetY); if (diffValue === null) continue; if (result.diffValue === null || result.diffValue &gt; diffValue) { result.isIncluded = true; result.diffValue = diffValue; result.offsetX = offsetX; result.offsetY = offsetY; }; if (diffValue === 0 || !this._saveMatch) return result; }; }; return result; }; /** * Gets used pixels. * * @method * @protected * @arg {object[][]} pixels - pixels matrix * @return {object[]} List of used pixels. */ Image.prototype._getUsedPixels = function (pixels) { var usedPixels = [], width = pixels[0].length, height = pixels.length, x, y, row; for (y = 0; y &lt; height; y++) { row = pixels[y]; for (x = 0; x &lt; width; x++) { if (this._isPixelUsed(row[x])) { usedPixels.push({ pixel: row[x], x: x, y: y }); }; }; }; return usedPixels; }; /** * Calculates difference between source pixels and destination pixels. * * @method * @protected * @arg {object[][]} srcPixels - source pixels matrix * @arg {object[][]} dstPixels - destination pixels matrix * @arg {number} offsetX - source left border offset * @arg {number} offsetY - source top border offset * @return {number} - difference value */ Image.prototype._getDiffValue = function (srcPixels, dstPixels, offsetX, offsetY) { var diffPixels = 0, limit = this._tolerance * dstPixels.length, dstPixel, srcPixel, i; for (i = 0; i &lt; dstPixels.length; i++) { dstPixel = dstPixels[i]; srcPixel = srcPixels[offsetY + dstPixel.y][offsetX + dstPixel.x]; if (this._isPixelTolerant(srcPixel, dstPixel.pixel)) continue; diffPixels++; if (diffPixels &gt; limit) return null; }; return diffPixels / dstPixels.length; }; /** * Defines whether pixel should be used for difference calculation or no, * according its alpha value. * * @method * @protected * @arg {object} pixel - pixel * @return {boolean} - `true` if should be, `false` otherwise */ Image.prototype._isPixelUsed = function (pixel) { return (255 - pixel.A) / 255 &lt; this._tolerance; }; /** * Defines whether source pixel is tolerant to destination pixel. * * @method * @protected * @arg {object} srcPixel - source pixel * @arg {object} dstPixel - destination pixel * @return {boolean} - `true` if pixels are tolerant, `false` otherwise */ Image.prototype._isPixelTolerant = function(srcPixel, dstPixel) { var deltaR = srcPixel.R - dstPixel.R, deltaG = srcPixel.G - dstPixel.G, deltaB = srcPixel.B - dstPixel.B; return Math.sqrt(deltaR * deltaR + deltaG * deltaG + deltaB * deltaB) / this._pixelDenominator &lt; this._tolerance; }; /** * Retrieves pixels from image data. * * @method * @protected * @arg {object} img - image data * @return {object[][]} - pixels matrix */ Image.prototype._getPixels = function (img) { var pixels = [], height = img.height, width = img.width * img.channels, x, y, offset; for (y = 0; y &lt; height; y++) { offset = width * y; pixels.push([]); for (x = 0; x &lt; width; x += img.channels) { pixels[y].push({ R: img.data[offset + x], G: img.data[offset + x + 1], B: img.data[offset + x + 2], A: img.hasAlpha ? img.data[offset + x + 3] : 255, }); }; }; return pixels; }; /** * Crops pixels, removes empty rows and columns. * * @method * @protected * @arg {object[][]} pixels - pixels matrix * @return {object[][]} - cropped pixels matrix */ Image.prototype._cropPixels = function (pixels) { pixels = this._cropTop(pixels); pixels.reverse(); pixels = this._cropTop(pixels); pixels.reverse(); pixels = this._transpose(pixels); pixels = this._cropTop(pixels); pixels.reverse(); pixels = this._cropTop(pixels); pixels.reverse(); return this._transpose(pixels); }; /** * Crops top part of pixels matrix. * * @method * @protected * @arg {object[][]} pixels - pixels matrix * @return {object[][]} - cropped pixels matrix */ Image.prototype._cropTop = function (pixels) { var croppedPixels = [], isTransparent = true, width = pixels[0].length, height = pixels.length, x, y, pixelsRow; for (y = 0; y &lt; height; y++) { pixelsRow = pixels[y]; if (isTransparent) { for (x = 0; x &lt; width; x++) { if (pixelsRow[x].A !== 0) { isTransparent = false; break; }; }; }; if (!isTransparent) croppedPixels.push(pixelsRow); }; return croppedPixels; }; /** * Transposes pixels matrix. * * @method * @arg {object[][]} pixels - pixels matrix * @return {object[][]} transposed pixels matrix */ Image.prototype._transpose = function (pixels) { var width = pixels[0].length, height = pixels.length, tPixels = [], x, y; if (width === 0 || height === 0) return []; for (y = 0; y &lt; width; y++) { tPixels[y] = []; for (x = 0; x &lt; height; x++) { tPixels[y][x] = pixels[x][y]; }; }; return tPixels; }; module.exports = Image; × Search results Close "},"steps.js.html":{"id":"steps.js.html","title":"Source: steps.js","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Source: steps.js &quot;use strict&quot;; /** * Steps to manage screenshots and images. * * These methods are mixed with glacejs [Steps](https://glacejs.github.io/glace-core/Steps.html) * class and available via its instance [$](https://glacejs.github.io/glace-core/global.html#$) * in tests. * * @mixin ImageSteps */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var fse = require(&quot;fs-extra&quot;); var screenshot = require(&quot;desktop-screenshot&quot;); var sharp = require(&quot;sharp&quot;); var temp = require(&quot;temp&quot;).track(); var uuid = require(&quot;uuid/v4&quot;); var U = require(&quot;glace-utils&quot;); var LOG = U.logger; require(&quot;./fixtures&quot;); var image = require(&quot;./image&quot;); sharp.cache(false); var ImageSteps = { __fs: fs, __screenshot: screenshot, __sharp: sharp, makeScreenshot: async function (opts) { /** * Step to make screenshot of browser or display. * * @async * @memberOf ImageSteps * @method makeScreenshot * @instance * @arg {object} [opts] - Step options. * @arg {string} [opts.imageName] - Screenshot name. File extension * `.png` will be added automatically. Default value is dynamically * generated on each call with algorithm `uuid`. * @arg {string} [opts.imageDirPath] - Screenshot folder path. * @arg {boolean} [opts.by] - Screenshot variant. Supported * values are `selenium`, `html2canvas`, `system`. By default * `selenium` if browser is launched, `system` otherwise. * @arg {?string} [opts.cssSelector=null] - CSS selector of DOM element * which of screenshot should be made. * @arg {?string} [opts.backColor=null] - Background color for html2canvas. * Transparent by default. * @arg {?function} [opts.preHook=null] - Function which will be called * in `Steps` context in the beginning of step. * @arg {?function} [opts.postHook=null] - Function which will be called * in `Steps` context at the end of step. * @arg {?string} [opts.element=null] - Web element name which should be * screenshotted. * @arg {boolean} [opts.check=true] - Flag to check screenshot is saved * or no. * @return {Promise&lt;string&gt;} Path to saved screenshot. * @throws {AssertionError} If screenshot isn't saved. * @example * * await $.makeScreenshot(); // saves screenshot with generated file name * await $.makeScreenshot({ imageName: &quot;my image&quot; }); // saves screenshot with custom name * await $.makeScreenshot({ imageName: &quot;my image&quot;, element: &quot;searchButton&quot; }); */ opts = U.defVal(opts, {}); var imageName = U.defVal(opts.imageName, uuid()); imageName = U.toKebab(imageName); if (!imageName.endsWith(&quot;.png&quot;)) imageName += &quot;.png&quot;; var imagePath = U.mkpath( U.defVal(opts.imageDirPath, getScreensDir()), imageName); var by = U.defVal(opts.by); var cssSelector = U.defVal(opts.cssSelector); var backColor = U.defVal(opts.backColor); var preHook = U.defVal(opts.preHook); var postHook = U.defVal(opts.postHook); var element = U.defVal(opts.element); var check = U.defVal(opts.check, true); if (!by) { if (this.webdriver &amp;&amp; await this.webdriver.session()) { by = &quot;selenium&quot;; } else { by = &quot;system&quot;; } } allure.step(`Screenshot with ${by}`); expect([&quot;selenium&quot;, &quot;html2canvas&quot;, &quot;system&quot;]).to.include(by); LOG.info(`Making screenshot with ${by}...`); if (preHook) await preHook.call(this); if (by === &quot;selenium&quot;) { await this._seleniumScreenshot(imagePath); }; if (by === &quot;html2canvas&quot;) { await this._canvasScreenshot( imagePath, { cssSelector: cssSelector, backColor: backColor }); }; if (by === &quot;system&quot;) { await this._displayScreenshot(imagePath); }; if (element) { await this._cutElement(imagePath, element, { path: imagePath }); }; if (check) { expect(fs.existsSync(imagePath), `Screenshot isn't saved to '${imagePath}'`).to.be.true; expect(await image(imagePath).isTransparent(), `Screenshot '${imagePath}' has empty content`).to.be.false; }; if (postHook) await postHook.call(this); CONF.test.curCase.addScreenshot(imagePath); LOG.info(`Screenshot is saved to ${imagePath}`); allure.attachImage(&quot;screenshot&quot;, imagePath); allure.pass(); return imagePath; }, checkImagesEquivalence: async function (actualImage, expectedImage, opts) { /** * Step to check whether two image are equal or not equal. * * @async * @memberOf ImageSteps * @method checkImagesEquivalence * @instance * @arg {string} actualImage - Path to actual image. * @arg {string} expectedImage - Path to expected image. * @arg {object} [opts] - Helper options. * @arg {number} [opts.threshold=0.05] - Threshold of divergence. * @arg {boolean} [opts.shouldBe=true] - Flag to check whether * image are equal or not equal. * @arg {string[]} [opts.elements=[]] - List of elements on image which * should be verified. * @arg {string} [opts.diffDirPath] - Path to diffs folder. * @return {Promise&lt;void&gt;} * @throws {AssertionError} If result of images comparison doesn't pass * requested parameters. * @example * * await $.checkImagesEquivalence(&quot;./actual.png&quot;, &quot;./expected.png&quot;); * await $.checkImagesEquivalence(&quot;./actual.png&quot;, &quot;./expected.png&quot;, { shouldBe: false }); */ opts = U.defVal(opts, {}); var elements = U.defVal(opts.elements, []); if (opts.shouldBe === false) { allure.step(`Check that image ${actualImage} isn't equal to ${expectedImage}`); } else { allure.step(`Check that image ${actualImage} is equal to ${expectedImage}`); } LOG.info(&quot;Checking images equivalence...&quot;); await this._checkImagesEquivalence(actualImage, expectedImage, opts); for (var element of elements) { var actualElImage = await this._cutElement( actualImage, element, { name: `actual ${element}` }); var expectedElImage = await this._cutElement( expectedImage, element, { name: `expected ${element}` }); await this._checkImagesEquivalence( actualElImage, expectedElImage, opts); }; LOG.info(&quot;Images equivalence is checked&quot;); allure.pass(); }, checkImageInclusion: async function (fullImage, includedImage, opts) { /** * Step to check one image includes or doesn't include another image. * * @async * @memberOf ImageSteps * @method checkImageInclusion * @instance * @arg {string} fullImage - Path to image which may include. * @arg {string} includedImage - Path to image which may be included. * @arg {object} [opts] - Step options. * @arg {object} [opts.matchedDirPath] - Folder path to save matched image. * @arg {number} [opts.threshold=0.05] - Threshold of divergence. * @arg {boolean} [opts.shouldBe=true] - Flag to check whether * image are equal or not equal. * @return {Promise&lt;void&gt;} * @throws {AssertionError} If result of images inclusion doesn't pass * requested parameters. * @example * * await $.checkImageInclusion(&quot;./full.png&quot;, &quot;./part.png&quot;); * await $.checkImageInclusion(&quot;./full.png&quot;, &quot;./part.png&quot;, { shouldBe: false }); */ opts = U.defVal(opts, {}); var threshold = U.defVal(opts.threshold, 0.05); var shouldBe = U.defVal(opts.shouldBe, true); if (shouldBe) { allure.step(`Check that image ${fullImage} includes ${includedImage}`); } else { allure.step(`Check that image ${fullImage} doesn't include ${includedImage}`); } var matchedImagePath = U.mkpath( U.defVal( opts.matchedDirPath, path.resolve(getScreensDir(), &quot;inclusions&quot;)), uuid() + &quot;.png&quot;); LOG.info(&quot;Checking images inclusion...&quot;); var result = await image(fullImage) .includes(includedImage, { tolerance: threshold, matchedPath: matchedImagePath }); if (shouldBe) { expect(result.isIncluded, `Image '${fullImage}' doesn't include '${includedImage}' but should`) .be.true; } else { expect(result.isIncluded, `Image '${fullImage}' includes '${includedImage}' but shouldn't`) .be.false; }; LOG.info(&quot;Images inclusion is checked&quot;); allure.pass(); }, resizeImage: async function (imgPath, percent, opts) { /** * Step to resize image. * * @async * @memberOf ImageSteps * @method resizeImage * @instance * @arg {string} imgPath - Path to resizing image. * @arg {string} [percent] - Percent to resize, for example `150%`. * @arg {object} [opts] - Step options. * @arg {string|number} [opts.width] - Width of resized image in pixels or percent. * @arg {string|number} [opts.height] - Height of resized image in pixels or percent. * @arg {boolean} [opts.check=true] - Check that image is resized. * @return {Promise} * @throws {AssertionError} If image path doesn't exist. * @throws {AssertionError} If image can't be resized. * @example * * await $.resizeImage(imgPath, &quot;75%&quot;); * await $.resizeImage(imgPath, { width: &quot;150%&quot;, height: &quot;125%&quot; }); * await $.resizeImage(imgPath, { width: 800, height: 600 }); */ var metadata, width, height, wPercent, hPercent; expect(fs.existsSync(imgPath), `Image '${imgPath}' doesn't exist`).to.be.true; if (typeof(percent) === &quot;object&quot;) { opts = percent; percent = undefined; } opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); if (typeof(opts.width) === &quot;string&quot; &amp;&amp; opts.width.endsWith(&quot;%&quot;)) { wPercent = parseInt(opts.width); } else if (opts.width === undefined) { wPercent = 100; } else { width = opts.width; } if (typeof(opts.height) === &quot;string&quot; &amp;&amp; opts.height.endsWith(&quot;%&quot;)) { hPercent = parseInt(opts.height); } else if (opts.height === undefined) { hPercent = 100; } else { height = opts.height; } if (typeof(percent) === &quot;string&quot; &amp;&amp; percent.endsWith(&quot;%&quot;)) { wPercent = hPercent = parseInt(percent); } if (wPercent &amp;&amp; hPercent) { metadata = await sharp(imgPath).metadata(); width = Math.ceil(metadata.width * wPercent / 100); height = Math.ceil(metadata.height * hPercent / 100); } allure.step(`Resize image ${imgPath} to [width=${width}, height=${height}]`); LOG.info(`Resizing image '${imgPath}' to [width=${width}, height=${height}]...`); var tmpPath = temp.path({ suffix: path.extname(imgPath) }); await sharp(imgPath).resize(width, height).toFile(tmpPath); if (check) { metadata = await sharp(tmpPath).metadata(); expect({ width: metadata.width, height: metadata.height }, `Can't resize image '${imgPath}'`) .to.be.eql({ width: width, height: height }); } fs.unlinkSync(imgPath); fse.moveSync(tmpPath, imgPath); LOG.info(&quot;Image is resized&quot;); allure.attachImage(&quot;resized&quot;, imgPath); allure.pass(); }, checkOrMakeScreenshot: async function (imageName, opts) { /** * Step to check or make screenshot of browser or display. * * @async * @memberOf ImageSteps * @method checkOrMakeScreenshot * @instance * @arg {string} imageName - Screenshot name. File extension * `.png` will be added automatically. * @arg {object} [opts] - Step options. * @arg {string} [opts.imageDirPath] - Screenshot folder path. * @arg {string} [opts.expectedDirPath] - Expected screenshot path. * @arg {boolean} [opts.by=selenium] - Screenshot variant. Supported * values are `selenium`, `html2canvas`, `system`. * @arg {?string} [opts.cssSelector=null] - C$ selector of DOM element * which of screenshot should be made. * @arg {?string} [opts.backColor=null] - Background color for html2canvas. * Transparent by default. * @arg {?function} [opts.preHook=null] - Function which will be called * in `Steps` context in the beginning of step. * @arg {?function} [opts.postHook=null] - Function which will be called * in `Steps` context at the end of step. * @arg {string[]} [opts.elements=[]] - List of elements on image which * should be verified. * @arg {string} [opts.diffDirPath] - Path to diffs folder. * @arg {boolean} [opts.check=true] - Flag to check screenshot is saved * or no. * @return {Promise&lt;void&gt;} * @throws {AssertionError} If screenshot isn't saved. * @example * * await $.checkOrMakeScreenshot(&quot;my image&quot;); * await $.checkOrMakeScreenshot(&quot;my image&quot;, { by: &quot;html2canvas&quot; }); */ imageName = U.toKebab(imageName); opts = U.defVal(opts, {}); opts.imageName = imageName; var actualImage = await this.makeScreenshot(opts); if (CONF.compareImages) { var testName = CONF.test.curCase ? U.toKebab(CONF.test.curCase.name) : &quot;&quot;; var expectedImage = path.resolve( U.defVal( opts.expectedDirPath, path.resolve(CONF.resourcesDir, testName, &quot;screenshots&quot;)), imageName + &quot;.png&quot;); await this.checkImagesEquivalence( actualImage, expectedImage, opts); }; }, /** * Helper to check two images are equal or not equal. * * @ignore * @async * @method * @protected * @instance * @arg {string} actualImage - Path to actual image. * @arg {string} expectedImage - Path to expected image. * @arg {object} [opts] - Helper options. * @arg {string} [opts.diffDirPath] - Path to diffs folder. * @arg {number} [opts.threshold=0.05] - Threshold of divergence. * @arg {boolean} [opts.shouldBe=true] - Flag to check whether * image are equal or not equal. * @return {Promise&lt;void&gt;} * @throws {AssertionError} - If actual image doesn't exist. * @throws {AssertionError} - If expected image doesn't exist. * @throws {AssertionError} - If result of images comparison don't pass * requested parameters. */ _checkImagesEquivalence: async function (actualImage, expectedImage, opts) { expect(fs.existsSync(actualImage), `Actual image '${actualImage}' doesn't exist`) .to.be.true; expect(fs.existsSync(expectedImage), `Expected image '${expectedImage}' doesn't exist`) .to.be.true; opts = U.defVal(opts, {}); var threshold = U.defVal(opts.threshold, 0.05); var shouldBe = U.defVal(opts.shouldBe, true); var diffImage = U.mkpath( U.defVal( opts.diffDirPath, path.resolve(getScreensDir(), &quot;diffs&quot;)), uuid() + &quot;.png&quot;); var percentage = await image(actualImage).equalTo( expectedImage, { tolerance: threshold, diffPath: diffImage }); if (shouldBe) { expect(percentage, `Image '${actualImage}' isn't equal to '${expectedImage}' ` + `but should. Diff image is '${diffImage}'`).be.lte(threshold); } else { expect(percentage, `Image '${actualImage}' is equal to '${expectedImage}' ` + `but shouldn't. Diff image is '${diffImage}'`).be.gte(threshold); }; }, /** * Helper to make screenshot of display. * * @ignore * @async * @method * @protected * @instance * @arg {string} imagePath - Path to screenshot which will be saved. * @return {Promise&lt;void&gt;} */ _displayScreenshot: async function (imagePath) { await new Promise((resolve, reject) =&gt; { this.__screenshot(imagePath, err =&gt; { if (err) return reject(err); resolve(); }); }); }, /** * Helper to make screenshot with selenium. * * @ignore * @async * @method * @protected * @instance * @arg {string} imagePath - Path to screenshot which will be saved. * @return {Promise&lt;void&gt;} */ _seleniumScreenshot: async function (imagePath) { await this.webdriver.saveScreenshot(imagePath); }, /** * Helper to make screenshot with html2canvas. * * @ignore * @async * @method * @protected * @instance * @arg {string} imagePath - Path to screenshot which will be saved. * @arg {object} [opts] - Helper options. * @arg {?string} [opts.cssSelector=null] - C$ selector of DOM element * which of screenshot should be made. * @arg {?string} [opts.backColor=null] - Background color, transparent by * default. * @arg {number} [opts.timeout=30000] - Time to wait for screenshot is * rendered, ms * @return {Promise&lt;void&gt;} * @throws {Error} - If screenshot will not be rendered during timeout. */ _canvasScreenshot: async function (imagePath, opts) { opts = U.defVal(opts, {}); var cssSelector = U.defVal(opts.cssSelector); var backColor = U.defVal(opts.backColor); var timeout = U.defVal(opts.timeout, 30000); var errMsg = &quot;Can't make screenshot&quot;; if (cssSelector) errMsg += &quot; of element with selector &quot; + cssSelector; /* istanbul ignore next */ await this.webdriver.execute(function (cssSelector, backColor) { function makeScreenshot () { var element; if (cssSelector) { element = document.querySelector(cssSelector); } else { element = document.body; }; html2canvas( element, { backgroundColor: backColor, useCORS: true // capture images from another domains }).then(function (canvas) { window.__screenshot = canvas .toDataURL() .split(&quot;data:image/png;base64,&quot;)[1]; }); }; if (typeof(html2canvas) !== &quot;undefined&quot;) { makeScreenshot(); return; }; var script = document.createElement(&quot;script&quot;); script.onload = makeScreenshot; script.src = &quot;http://html2canvas.hertzen.com/dist/html2canvas.min.js&quot;; document.body.appendChild(script); }, cssSelector, backColor); var screenBase64 = await this.webdriver.waitUntil(async () =&gt; { /* istanbul ignore next */ return (await this.webdriver.execute(function () { var result; if (window.__screenshot) { result = window.__screenshot; delete window.__screenshot; } else { result = false; }; return result; })).value; }, timeout, errMsg); fs.writeFileSync(imagePath, screenBase64, &quot;base64&quot;); }, /** * Helper to cut element from image. * * @ignore * @async * @method * @protected * @instance * @arg {string} imagePath - Path to image which element will be cut from. * @arg {string} elementName - Name of element which will be cut. * @arg {object} [opts] - Helper options. * @arg {string} [opts.path] - Path to cut image. * @arg {string} [opts.dirPath] - Folder path to cut image. * @arg {string} [opts.name] - Name of cut image with element. * @return {Promise&lt;string&gt;} - Path to cut image. * @throws {AssertionError} - If original image doesn't exist. * @throws {AssertionError} - If DOM element is not registered in config. * @throws {AssertionError} - If cut image is not saved. */ _cutElement: async function (imagePath, elementName, opts) { expect(this.__fs.existsSync(imagePath), `Image ${imagePath} doesn't exist`).be.true; var eLoc = await this.__getElementLocation(elementName, imagePath); opts = U.defVal(opts, {}); var targetName = U.toKebab(U.defVal(opts.name, uuid())); if (!targetName.endsWith(&quot;.png&quot;)) targetName += &quot;.png&quot;; var targetPath = U.mkpath( U.defVal( opts.path, path.resolve( U.defVal(opts.dirPath, path.resolve(getScreensDir(), &quot;cut-elements&quot;)), targetName))); if (imagePath === targetPath) { this.__fs.renameSync(imagePath, imagePath + &quot;.tmp&quot;); imagePath += &quot;.tmp&quot;; }; await new Promise((resolve, reject) =&gt; { this.__sharp(imagePath) .extract({ left: eLoc.x, top: eLoc.y, width: eLoc.width, height: eLoc.height }) .crop(sharp.strategy.entropy) .toFile(targetPath, err =&gt; { if (err) reject(err); resolve(); }); }); expect(this.__fs.existsSync(targetPath, `Image ${targetPath} isn't saved`)).be.true; if (imagePath.endsWith(&quot;.tmp&quot;)) this.__fs.unlinkSync(imagePath); return targetPath; }, /** * Helper to get element location. * * @ignore * @async * @method * @private * @instance * @arg {string} name - Element name. * @arg {string} imagePath - Path to image. * @return {object} - Dict with `x`, `y`, `width`, `height` keys. */ __getElementLocation: async function (name, imagePath) { var element = await this.getElement(name); var imageInfo = await new Promise((resolve, reject) =&gt; { this.__sharp(imagePath).toBuffer((err, outputBuffer, info) =&gt; { if (err) reject(err); resolve(info); }); }); imageInfo.x = 0; imageInfo.y = 0; var eLoc = await element.location(); return U.objOnScreenPos(eLoc, imageInfo); }, }; module.exports = ImageSteps; /** * Helper to get screenshots folder. * * @ignore * @function */ var getScreensDir = () =&gt; { return path.resolve(CONF.report.testDir || CONF.report.dir, &quot;screenshots&quot;); }; × Search results Close "},"fixtures_index.js.html":{"id":"fixtures_index.js.html","title":"Source: fixtures/index.js","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Source: fixtures/index.js &quot;use strict&quot;; /** * Image fixtures. * * @module */ global.fxScreenOnFail = require(&quot;./fxScreenOnFail&quot;); × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Source: index.js &quot;use strict&quot;; /** * `GlaceJS Image` plugin. * * @module */ var config, pluginHelp, Steps; Object.defineProperties(exports, { /** * @type {GlaceConfig} */ config: { get: function() { config = config || require(&quot;./config&quot;); return config; }, }, /** * @type {pluginHelp} */ pluginHelp: { get: function () { pluginHelp = pluginHelp || require(&quot;./pluginHelp&quot;); return pluginHelp; } }, /** * @type {ImageSteps} */ Steps: { get: function() { Steps = Steps || require(&quot;./steps&quot;); return Steps; }, }, }); × Search results Close "},"pluginHelp.js.html":{"id":"pluginHelp.js.html","title":"Source: pluginHelp.js","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Source: pluginHelp.js &quot;use strict&quot;; /** * `Image` plugin help. * * @function * @name pluginHelp * @arg {yargs} yargs - `yargs` instance in order to expand its options. * @arg {function} d - Function to manage option description: join, colorize, etc. * @return {yargs} - Expanded `yargs` instance. */ module.exports = (args, d) =&gt; { return args .options({ &quot;screenshot-on-fail&quot;: { describe: d(&quot;Capture screenshot on chunk fail.&quot;), type: &quot;boolean&quot;, group: &quot;Image:&quot;, }, }); }; × Search results Close "},"fixtures_fxScreenOnFail.js.html":{"id":"fixtures_fxScreenOnFail.js.html","title":"Source: fixtures/fxScreenOnFail.js","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Source: fixtures/fxScreenOnFail.js &quot;use strict&quot;; /** * Fixture make screenshon on chunk failure. * * @function */ const U = require(&quot;glace-utils&quot;); const LOG = U.logger; const beforeChunkCb = ctx =&gt; () =&gt; { ctx.errNumber = CONF.test.curCase.errors.length; }; const afterChunkCb = ctx =&gt; async () =&gt; { if (CONF.test.curCase.errors.length === ctx.errNumber) return; var opts = { imageName: `fail ${CONF.test.curCase.name} ${CONF.test.curCase.chunks[0]}` }; try { if ($.webdriver &amp;&amp; await $.webdriver.session()) { opts.by = &quot;selenium&quot;; } else { opts.by = &quot;system&quot;; }; } catch (e) { opts.by = &quot;system&quot;; }; try { await $.makeScreenshot(opts); } catch (e) { LOG.error(e); }; }; module.exports = U.makeFixture({ beforeChunk: beforeChunkCb, afterChunk: afterChunkCb }); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Global Methods pluginHelp(yargs, d) Image plugin help. Parameters: Name Type Description yargs yargs yargs instance in order to expand its options. d function Function to manage option description: join, colorize, etc. Source: pluginHelp.js, line 2 Returns: Expanded yargs instance. Type yargs U() Fixture make screenshon on chunk failure. Source: fixtures/fxScreenOnFail.js, line 9 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Modules Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Classes Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Namespaces Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Mixins Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Tutorials Classes Image Mixins ImageSteps Namespaces GlaceConfig × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU | Source Code | Release Notes GlaceJS Image pluginProvides steps for GlaceJS framework to process images and screenshots. Features Image capture via selenium Image capture via html2canvas Image capture via system screenshot Images comparision mechanism via pixelmatch Search image inside image via own pixel-by-pixel algorithm How to installnpm i glace-imageHow to usevar glaceImage = require(&quot;glace-image&quot;); glaceImage.Steps; glaceImage.config;If plugin is used as a part of GlaceJS it will be loaded automatically. API config steps Test examplesSee integration tests in order to explore examples. Tests and quality Project tests report is here Code coverage report is here × Search results Close "},"GlaceConfig.html":{"id":"GlaceConfig.html","title":"Namespace: GlaceConfig","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Namespace: GlaceConfig GlaceConfig Configures Image plugin. Extends GlaceJS configuration. Source: config.js, line 2 × Search results Close "},"Image.html":{"id":"Image.html","title":"Class: Image","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Class: Image Image new Image(srcPath [, srcOpts] [, injects]) Creates new instance of Image. Parameters: Name Type Argument Description srcPath string path to processed image srcOpts object &lt;optional&gt; image options Properties Name Type Argument Default Description scaleX number &lt;optional&gt; 1 image current scale value on X axis scaleY number &lt;optional&gt; 1 image current scale value on Y axis injects object &lt;optional&gt; Dependency injections. Properties Name Type Argument Description sharp object &lt;optional&gt; Injected sharp module. Source: image.js, line 2 Methods &lt;protected&gt; _cropPixels(pixels) Crops pixels, removes empty rows and columns. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 480 Returns: cropped pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; &lt;protected&gt; _cropTop(pixels) Crops top part of pixels matrix. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 501 Returns: cropped pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; &lt;protected&gt; _getDiffValue(srcPixels, dstPixels, offsetX, offsetY) Calculates difference between source pixels and destination pixels. Parameters: Name Type Description srcPixels Array.&lt;Array.&lt;object&gt;&gt; source pixels matrix dstPixels Array.&lt;Array.&lt;object&gt;&gt; destination pixels matrix offsetX number source left border offset offsetY number source top border offset Source: image.js, line 392 Returns: difference value Type number &lt;protected&gt; _getPixels(img) Retrieves pixels from image data. Parameters: Name Type Description img object image data Source: image.js, line 451 Returns: pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; &lt;protected&gt; _getUsedPixels(pixels) Gets used pixels. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 361 Returns: List of used pixels. Type Array.&lt;object&gt; &lt;protected&gt; _includes(src, dst) Defines whether one image data includes another. Parameters: Name Type Description src object source image data dst object destination image data, which is potentially included Source: image.js, line 311 Returns: result Type object &lt;protected&gt; _isPixelTolerant(srcPixel, dstPixel) Defines whether source pixel is tolerant to destination pixel. Parameters: Name Type Description srcPixel object source pixel dstPixel object destination pixel Source: image.js, line 433 Returns: true if pixels are tolerant, false otherwise Type boolean &lt;protected&gt; _isPixelUsed(pixel) Defines whether pixel should be used for difference calculation or no, according its alpha value. Parameters: Name Type Description pixel object pixel Source: image.js, line 421 Returns: true if should be, false otherwise Type boolean &lt;async, protected&gt; _loadImg(imgPath, imgOpts) Loads image. Parameters: Name Type Description imgPath string path loaded image imgOpts object image options Source: image.js, line 268 Returns: image data Type Promise.&lt;object&gt; &lt;async, protected&gt; _saveMatchImage(left, top, width, height) Saves matched part of image. Parameters: Name Type Description left number offset from left image border top number offset from top image border width number width of matched part height number height of matched part Source: image.js, line 297 Returns: Type Promise.&lt;void&gt; _transpose(pixels) Transposes pixels matrix. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 533 Returns: transposed pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; equalTo(dstPath [, dstOpts]) Defines if processed image equal to specified image. Parameters: Name Type Argument Description dstPath string path to potentially equal image dstOpts object &lt;optional&gt; included image options Properties Name Type Argument Default Description tolerance number &lt;optional&gt; 0.05 comparison tolerance diffPath string &lt;optional&gt; &lt;nullable&gt; null path to save captured difference. saveDiff boolean &lt;optional&gt; false flag to capture images intersection or no Source: image.js, line 214 Returns: Ratio of difference. Type Promise.&lt;number&gt; includes(dstPath [, dstOpts]) Defines if processed image includes specified image. Parameters: Name Type Argument Description dstPath string path to potentially included image dstOpts object &lt;optional&gt; included image options Properties Name Type Argument Default Description tolerance number &lt;optional&gt; 0.05 comparison tolerance matchedPath string &lt;optional&gt; &lt;nullable&gt; null path to same captured place saveMatch boolean &lt;optional&gt; false flag to capture images intersection or no Source: image.js, line 166 Returns: result Type Promise.&lt;object&gt; &lt;async&gt; isBlack() Defines whether processed image is black. Source: image.js, line 105 Returns: true if image is black, false otherwise. Type Promise.&lt;boolean&gt; &lt;async&gt; isMonochrome() Defines whether processed image is monochrome. Source: image.js, line 75 Returns: true if image is monochrome, false otherwise. Type Promise.&lt;boolean&gt; &lt;async&gt; isTransparent() Defines whether processed image is transparent. Source: image.js, line 51 Returns: true if image is transparent, false otherwise. Type Promise.&lt;boolean&gt; &lt;async&gt; isWhite() Defines whether processed image is white. Source: image.js, line 133 Returns: true if image is white, false otherwise. Type Promise.&lt;boolean&gt; × Search results Close "},"ImageSteps.html":{"id":"ImageSteps.html","title":"Mixin: ImageSteps","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Mixin: ImageSteps ImageSteps Steps to manage screenshots and images. These methods are mixed with glacejs Steps class and available via its instance $ in tests. Source: steps.js, line 2 Methods &lt;async&gt; checkImageInclusion(fullImage, includedImage [, opts]) Step to check one image includes or doesn't include another image. Parameters: Name Type Argument Description fullImage string Path to image which may include. includedImage string Path to image which may be included. opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description matchedDirPath object &lt;optional&gt; Folder path to save matched image. threshold number &lt;optional&gt; 0.05 Threshold of divergence. shouldBe boolean &lt;optional&gt; true Flag to check whether image are equal or not equal. Source: steps.js, line 188 Throws: If result of images inclusion doesn't pass requested parameters. Type AssertionError Returns: Type Promise.&lt;void&gt; Example await $.checkImageInclusion(&quot;./full.png&quot;, &quot;./part.png&quot;); await $.checkImageInclusion(&quot;./full.png&quot;, &quot;./part.png&quot;, { shouldBe: false }); &lt;async&gt; checkImagesEquivalence(actualImage, expectedImage [, opts]) Step to check whether two image are equal or not equal. Parameters: Name Type Argument Description actualImage string Path to actual image. expectedImage string Path to expected image. opts object &lt;optional&gt; Helper options. Properties Name Type Argument Default Description threshold number &lt;optional&gt; 0.05 Threshold of divergence. shouldBe boolean &lt;optional&gt; true Flag to check whether image are equal or not equal. elements Array.&lt;string&gt; &lt;optional&gt; [] List of elements on image which should be verified. diffDirPath string &lt;optional&gt; Path to diffs folder. Source: steps.js, line 138 Throws: If result of images comparison doesn't pass requested parameters. Type AssertionError Returns: Type Promise.&lt;void&gt; Example await $.checkImagesEquivalence(&quot;./actual.png&quot;, &quot;./expected.png&quot;); await $.checkImagesEquivalence(&quot;./actual.png&quot;, &quot;./expected.png&quot;, { shouldBe: false }); &lt;async&gt; checkOrMakeScreenshot(imageName [, opts]) Step to check or make screenshot of browser or display. Parameters: Name Type Argument Description imageName string Screenshot name. File extension .png will be added automatically. opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description imageDirPath string &lt;optional&gt; Screenshot folder path. expectedDirPath string &lt;optional&gt; Expected screenshot path. by boolean &lt;optional&gt; selenium Screenshot variant. Supported values are selenium, html2canvas, system. cssSelector string &lt;optional&gt; &lt;nullable&gt; null C$ selector of DOM element which of screenshot should be made. backColor string &lt;optional&gt; &lt;nullable&gt; null Background color for html2canvas. Transparent by default. preHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context in the beginning of step. postHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context at the end of step. elements Array.&lt;string&gt; &lt;optional&gt; [] List of elements on image which should be verified. diffDirPath string &lt;optional&gt; Path to diffs folder. check boolean &lt;optional&gt; true Flag to check screenshot is saved or no. Source: steps.js, line 332 Throws: If screenshot isn't saved. Type AssertionError Returns: Type Promise.&lt;void&gt; Example await $.checkOrMakeScreenshot(&quot;my image&quot;); await $.checkOrMakeScreenshot(&quot;my image&quot;, { by: &quot;html2canvas&quot; }); &lt;async&gt; makeScreenshot( [opts]) Step to make screenshot of browser or display. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description imageName string &lt;optional&gt; Screenshot name. File extension .png will be added automatically. Default value is dynamically generated on each call with algorithm uuid. imageDirPath string &lt;optional&gt; Screenshot folder path. by boolean &lt;optional&gt; Screenshot variant. Supported values are selenium, html2canvas, system. By default selenium if browser is launched, system otherwise. cssSelector string &lt;optional&gt; &lt;nullable&gt; null CSS selector of DOM element which of screenshot should be made. backColor string &lt;optional&gt; &lt;nullable&gt; null Background color for html2canvas. Transparent by default. preHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context in the beginning of step. postHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context at the end of step. element string &lt;optional&gt; &lt;nullable&gt; null Web element name which should be screenshotted. check boolean &lt;optional&gt; true Flag to check screenshot is saved or no. Source: steps.js, line 34 Throws: If screenshot isn't saved. Type AssertionError Returns: Path to saved screenshot. Type Promise.&lt;string&gt; Example await $.makeScreenshot(); // saves screenshot with generated file name await $.makeScreenshot({ imageName: &quot;my image&quot; }); // saves screenshot with custom name await $.makeScreenshot({ imageName: &quot;my image&quot;, element: &quot;searchButton&quot; }); &lt;async&gt; resizeImage(imgPath [, percent] [, opts]) Step to resize image. Parameters: Name Type Argument Description imgPath string Path to resizing image. percent string &lt;optional&gt; Percent to resize, for example 150%. opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description width string | number &lt;optional&gt; Width of resized image in pixels or percent. height string | number &lt;optional&gt; Height of resized image in pixels or percent. check boolean &lt;optional&gt; true Check that image is resized. Source: steps.js, line 248 Throws: If image path doesn't exist. Type AssertionError If image can't be resized. Type AssertionError Returns: Type Promise Example await $.resizeImage(imgPath, &quot;75%&quot;); await $.resizeImage(imgPath, { width: &quot;150%&quot;, height: &quot;125%&quot; }); await $.resizeImage(imgPath, { width: 800, height: 600 }); × Search results Close "},"module-fixtures_index.html":{"id":"module-fixtures_index.html","title":"Module: fixtures/index","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Module: fixtures/index Image fixtures. Source: fixtures/index.js, line 3 × Search results Close "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Module: index GlaceJS Image plugin. Source: index.js, line 2 Members &lt;inner&gt; config :GlaceConfig Type: GlaceConfig Source: index.js, line 14 &lt;inner&gt; pluginHelp :pluginHelp Type: pluginHelp Source: index.js, line 23 &lt;inner&gt; Steps :ImageSteps Type: ImageSteps Source: index.js, line 32 × Search results Close "},"tutorial-release-notes.html":{"id":"tutorial-release-notes.html","title":"Tutorial: Release Notes","body":" GlaceJS Namespaces GlaceConfig Modules fixtures/indexindex Classes Image Mixins ImageSteps Tutorials Release Notes Global pluginHelpU Release Notes v1.2.9 Used fixtures factory. v1.2.8 Updated dependencies. v1.2.7 Updated glace-core. Started to use $ only. v1.2.6 Started to support slaves mechanism. v1.2.5 Migrated to new glace-core. v1.2.4 Updated dependencies. v1.2.3 Added image paths to error messages in image checks. v1.2.2 Added allure steps. v1.2.1 Removed image magick configuration. v1.2.0 Added step to resize image. Removed image-diff and binary dependencies. v1.1.1 Added dynamic switching between screenshot variants. v1.1.0 Added project workflow commands. Logged steps. v1.0.9 Used docstring style in steps. v1.0.8 Added fixture and CLI option to capture screenshot on chunk failure. v1.0.7 Support background color for html2canvas in steps. v1.0.6 Updated html2canvas. Fixed bug that element screenshot didn't replace browser screenshot. Added option to pass image path in method to cut element. v1.0.5 Fixes according to unit tests results. Dependencies updating. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
