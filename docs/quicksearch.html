<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"config.js.html":{"id":"config.js.html","title":"Source: config.js","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Source: config.js &quot;use strict&quot;; /** * Configures `Image` plugin. Extends `GlaceJS` configuration. * * @namespace GlaceConfig */ var U = require(&quot;glace-utils&quot;); var config = U.config; if (process.platform === &quot;win32&quot;) { require(&quot;binary&quot;).activateImageMagick(); }; module.exports = config; Ã— Search results Close "},"image.js.html":{"id":"image.js.html","title":"Source: image.js","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Source: image.js &quot;use strict&quot;; /** * Creates new instance of Image. * * @class * @name Image * @arg {string} srcPath - path to processed image * @arg {object} [srcOpts] - image options * @arg {number} [srcOpts.scaleX=1] - image current scale value on `X` axis * @arg {number} [srcOpts.scaleY=1] - image current scale value on `Y` axis */ var sharp = require(&quot;sharp&quot;); var temp = require(&quot;temp&quot;); var U = require(&quot;glace-utils&quot;); sharp.cache(false); var Image = function (srcPath, srcOpts) { if (!(this instanceof Image)) return new Image(srcPath, srcOpts); srcOpts = U.defVal(srcOpts, {}); srcOpts.scaleX = U.defVal(srcOpts.scaleX, 1); srcOpts.scaleY = U.defVal(srcOpts.scaleY, 1); this._srcPath = srcPath; this._srcOpts = srcOpts; }; /** * Defines whether processed image is transparent. * * @async * @method * @return {Promise.&lt;boolean&gt;} - `true` if image is transparent, `false` * otherwise. */ Image.prototype.isTransparent = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== 0) return false; }; }; return true; }); }; /** * Defines whether processed image is monochrome. * * @async * @method * @return {Promise.&lt;boolean&gt;} - `true` if image is monochrome, `false` * otherwise. */ Image.prototype.isMonochrome = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; var firstPixel = pixels[0][0]; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== firstPixel.A || row[x].R !== firstPixel.R || row[x].G !== firstPixel.G || row[x].B !== firstPixel.B) { return false; }; }; }; return true; }); }; /** * Defines whether processed image is black. * * @async * @method * @return {Promise.&lt;boolean&gt;} - `true` if image is black, `false` otherwise. */ Image.prototype.isBlack = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== 255 || row[x].R !== 0 || row[x].G !== 0 || row[x].B !== 0) { return false; }; }; }; return true; }); }; /** * Defines whether processed image is white. * * @async * @method * @return {Promise.&lt;boolean&gt;} - `true` if image is white, `false` otherwise. */ Image.prototype.isWhite = function () { return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { var pixels = this._getPixels(image); var height = pixels.length; var width = pixels[0].length; for (var y = 0; y &lt; height; y++) { var row = pixels[y]; for (var x = 0; x &lt; width; x++) { if (row[x].A !== 255 || row[x].R !== 255 || row[x].G !== 255 || row[x].B !== 255) { return false; }; }; }; return true; }); }; /** * Defines if processed image includes specified image. * * @method * @arg {string} dstPath - path to potentially included image * @arg {object} [dstOpts] - included image options * @arg {number} [dstOpts.tolerance=0.05] - comparison tolerance * @arg {?string} [dstOpts.matchedPath=null] - path to same captured place * @arg {boolean} [dstOpts.saveMatch=false] - flag to capture images * intersection or no * @return {Promise.&lt;object&gt;} - result */ Image.prototype.includes = function (dstPath, dstOpts) { dstOpts = U.defVal(dstOpts, {}); dstOpts.scaleX = U.defVal(dstOpts.scaleX, 1); dstOpts.scaleY = U.defVal(dstOpts.scaleY, 1); this._dstPath = dstPath; this._dstOpts = dstOpts; this._tolerance = U.defVal(dstOpts.tolerance, .05); this._matchedPath = U.defVal(dstOpts.matchedPath); this._saveMatch = U.defVal(dstOpts.saveMatch, !!this._matchedPath); if (this._saveMatch &amp;&amp; !this._matchedPath) this._matchedPath = temp.path({ suffix: '.png' }); this._pixelDenominator = 255 * Math.sqrt(3); var srcImage; return this._loadImg(this._srcPath, this._srcOpts).then(image =&gt; { srcImage = image; return this._loadImg(this._dstPath, this._dstOpts); }).then(dstImage =&gt; { return this._includes(srcImage, dstImage); }).then(result =&gt; { if (!result.isIncluded) return { isIncluded: false }; if (!this._saveMatch) return result; return this ._saveMatchImage(result.offsetX, result.offsetY, result.width, result.height) .then(() =&gt; { result.matchedPath = this._matchedPath; return result; }); }); }; /** * Loads image. * * @method * @protected * @arg {string} imgPath - path loaded image * @arg {object} imgOpts - image options * @return {Promise.&lt;object&gt;} - image data */ Image.prototype._loadImg = function(imgPath, imgOpts) { var width, height, hasAlpha, channels; var img = sharp(imgPath); return img.metadata().then(metadata =&gt; { hasAlpha = metadata.hasAlpha; channels = metadata.channels; width = Math.ceil(metadata.width / imgOpts.scaleX); height = Math.ceil(metadata.height / imgOpts.scaleY); return img.resize(width, height).raw().toBuffer(); }).then(data =&gt; { return { width: width, height: height, data: data, channels: channels, hasAlpha: hasAlpha }; }); }; /** * Saves matched part of image. * * @method * @protected * @arg {number} left - offset from left image border * @arg {number} top - offset from top image border * @arg {number} width - width of matched part * @arg {number} height - height of matched part * @return {Promise} */ Image.prototype._saveMatchImage = function (left, top, width, height) { return sharp(this._srcPath) .extract({ left: left, top: top, width: width, height: height }) .toFile(this._matchedPath); }; /** * Defines whether one image data includes another. * * @method * @protected * @arg {object} src - source image data * @arg {object} dst - destination image data, which is potentially included * @return {object} - result */ Image.prototype._includes = function (src, dst) { var srcPixels = this._cropPixels(this._getPixels(src)), dstPixels = this._cropPixels(this._getPixels(dst)); var offsetX, offsetY, diffValue, x, y, pixels; var dstUsedPixels = [], dstWidth = dstPixels[0].length, dstHeight = dstPixels.length; var result = { isIncluded: false, diffValue: null, offsetX: null, offsetY: null, width: dstWidth, height: dstHeight }; var deltaX = srcPixels[0].length - dstWidth, deltaY = srcPixels.length - dstHeight; for (y = 0; y &lt; dstHeight; y++) { pixels = dstPixels[y]; for (x = 0; x &lt; dstWidth; x++) { if (this._isPixelUsed(pixels[x])) dstUsedPixels.push({ pixel: pixels[x], x: x, y: y }); }; }; for (offsetY = 0; offsetY &lt;= deltaY; offsetY++) { for (offsetX = 0; offsetX &lt;= deltaX; offsetX++) { diffValue = this._getDiffValue(srcPixels, dstUsedPixels, offsetX, offsetY); if (diffValue === null) continue; if (result.diffValue === null || result.diffValue &gt; diffValue) { result.isIncluded = true; result.diffValue = diffValue; result.offsetX = offsetX; result.offsetY = offsetY; }; if (diffValue === 0 || !this._saveMatch) return result; }; }; return result; }; /** * Calculates difference between source pixels and destination pixels. * * @method * @protected * @arg {object[][]} - source pixels matrix * @arg {object[][]} - destination pixels matrix * @arg {number} offsetX - source left border offset * @arg {number} offsetY - source top border offset * @return {number} - difference value */ Image.prototype._getDiffValue = function (srcPixels, dstPixels, offsetX, offsetY) { var diffPixels = 0, limit = this._tolerance * dstPixels.length, dstPixel, srcPixel, i; for (i = 0; i &lt; dstPixels.length; i++) { dstPixel = dstPixels[i]; srcPixel = srcPixels[offsetY + dstPixel.y][offsetX + dstPixel.x]; if (this._isPixelTolerant(srcPixel, dstPixel.pixel)) continue; diffPixels++; if (diffPixels &gt; limit) return null; }; return diffPixels / dstPixels.length; }; /** * Defines whether pixel should be used for difference calculation or no, * according its alpha value. * * @method * @protected * @arg {object} pixel - pixel * @return {boolean} - `true` if should be, `false` otherwise */ Image.prototype._isPixelUsed = function (pixel) { return (255 - pixel.A) / 255 &lt; this._tolerance; }; /** * Defines whether source pixel is tolerant to destination pixel. * * @method * @protected * @arg {object} srcPixel - source pixel * @arg {object} dstPixel - destination pixel * @return {boolean} - `true` if pixels are tolerant, `false` otherwise */ Image.prototype._isPixelTolerant = function(srcPixel, dstPixel) { var deltaR = srcPixel.R - dstPixel.R, deltaG = srcPixel.G - dstPixel.G, deltaB = srcPixel.B - dstPixel.B; return Math.sqrt(deltaR * deltaR + deltaG * deltaG + deltaB * deltaB) / this._pixelDenominator &lt; this._tolerance; }; /** * Retrieves pixels from image data. * * @method * @protected * @arg {object} img - image data * @return {object[][]} - pixels matrix */ Image.prototype._getPixels = function (img) { var pixels = [], height = img.height, width = img.width * img.channels, x, y, offset; for (y = 0; y &lt; height; y++) { offset = width * y; pixels.push([]); for (var x = 0; x &lt; width; x += img.channels) { pixels[y].push({ R: img.data[offset + x], G: img.data[offset + x + 1], B: img.data[offset + x + 2], A: img.hasAlpha ? img.data[offset + x + 3] : 255, }); }; }; return pixels; }; /** * Crops pixels, removes empty rows and columns. * * @method * @protected * @arg {object[][]} pixels - pixels matrix * @return {object[][]} - cropped pixels matrix */ Image.prototype._cropPixels = function (pixels) { pixels = this._cropTop(pixels); pixels.reverse(); pixels = this._cropTop(pixels); pixels.reverse(); pixels = this._transpose(pixels); pixels = this._cropTop(pixels); pixels.reverse(); pixels = this._cropTop(pixels); pixels.reverse(); return this._transpose(pixels); }; /** * Crops top part of pixels matrix. * * @method * @protected * @arg {object[][]} pixels - pixels matrix * @return {object[][]} - cropped pixels matrix */ Image.prototype._cropTop = function (pixels) { var croppedPixels = [], isTransparent = true, width = pixels[0].length, height = pixels.length, x, y, pixelsRow; for (y = 0; y &lt; height; y++) { pixelsRow = pixels[y]; if (isTransparent) { for (x = 0; x &lt; width; x++) { if (pixelsRow[x].A !== 0) { isTransparent = false; break; }; }; }; if (!isTransparent) croppedPixels.push(pixelsRow); }; return croppedPixels; }; /** * Transposes pixels matrix. * * @method * @arg {object[][]} pixels - pixels matrix * @return {object[][]} transposed pixels matrix */ Image.prototype._transpose = function (pixels) { var width = pixels[0].length, height = pixels.length, tPixels = [], x, y; if (width === 0 || height === 0) return []; for (y = 0; y &lt; width; y++) { tPixels[y] = []; for (x = 0; x &lt; height; x++) { tPixels[y][x] = pixels[x][y]; }; }; return tPixels; }; module.exports = Image; Ã— Search results Close "},"steps.js.html":{"id":"steps.js.html","title":"Source: steps.js","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Source: steps.js &quot;use strict&quot;; /** * Steps to manage screenshots and images. * * @mixin ImageSteps */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var _ = require(&quot;lodash&quot;); var imageDiff = require(&quot;image-diff&quot;); var screenshot = require(&quot;desktop-screenshot&quot;); var sharp = require(&quot;sharp&quot;); var uuid = require(&quot;uuid/v4&quot;); var U = require(&quot;glace-utils&quot;); var image = require(&quot;./image&quot;); sharp.cache(false); var ImageSteps = { /** * Used imports. */ __screenshot: screenshot, /** * Step to make web screenshot in browser. * * @async * @method * @instance * @arg {object} [opts] - Step options. * @arg {string} [opts.imageName] - Screenshot name. File extension * `.png` will be added automatically. Default value is dynamically * generated on each call with algorithm `uuid`. * @arg {string} [opts.imageDirPath] - Screenshot folder path. * @arg {boolean} [opts.by=selenium] - Screenshot variant. Supported * values are &quot;selenium&quot;, &quot;html2canvas&quot;, &quot;system&quot;. * @arg {?string} [opts.cssSelector=null] - CSS selector of DOM element * which of screenshot should be made. * @arg {?function} [opts.preHook=null] - Function which will be called * in `Steps` context in the beginning of step. * @arg {?function} [opts.postHook=null] - Function which will be called * in `Steps` context at the end of step. * @arg {?string} [opts.element=null] - Web element name which should be * screenshotted. * @arg {boolean} [opts.check=true] - Flag to check screenshot is saved * or no. * @return {Promise&lt;string&gt;} - Path to saved screenshot. * @throws {AssertionError} - If screenshot isn't saved. */ makeScreenshot: async function (opts) { opts = U.defVal(opts, {}); var imageName = U.defVal(opts.imageName, uuid()); imageName = kebab(imageName); if (!imageName.endsWith(&quot;.png&quot;)) imageName += &quot;.png&quot;; var imagePath = U.mkpath( U.defVal(opts.imageDirPath, getScreensDir()), imageName); var by = U.defVal(opts.by, &quot;selenium&quot;); var cssSelector = U.defVal(opts.cssSelector); var preHook = U.defVal(opts.preHook); var postHook = U.defVal(opts.postHook); var element = U.defVal(opts.element); var check = U.defVal(opts.check, true); expect([&quot;selenium&quot;, &quot;html2canvas&quot;, &quot;system&quot;]).to.include(by); if (preHook) await preHook.call(this); if (by === &quot;selenium&quot;) { await this._seleniumScreenshot(imagePath); }; if (by === &quot;html2canvas&quot;) { await this._canvasScreenshot( imagePath, { cssSelector: cssSelector }); }; if (by === &quot;system&quot;) { await this._displayScreenshot(imagePath); }; if (element) { await this._cutElement(imagePath, element, { path: imagePath }); }; if (check) { expect(fs.existsSync(imagePath), `Screenshot isn't saved to '${imagePath}'`).to.be.true; expect(await image(imagePath).isTransparent(), `Screenshot '${imagePath}' has empty content`).to.be.false; }; if (postHook) await postHook.call(this); CONF.curTestCase.addScreenshot(imagePath); return imagePath; }, /** * Step to check two image are equal or not equal * * @async * @method * @instance * @arg {string} actualImage - Path to actual image. * @arg {string} expectedImage - Path to expected image. * @arg {object} [opts] - Helper options. * @arg {number} [opts.threshold=0.05] - Threshold of divergence. * @arg {boolean} [opts.shouldBe=true] - Flag to check whether * image are equal or not equal. * @arg {string[]} [opts.elements=[]] - List of elements on image which * should be verified. * @return {Promise&lt;void&gt;} * @throws {AssertionError} - If result of images comparison don't pass * requested parameters. */ checkImagesEquivalence: async function (actualImage, expectedImage, opts) { opts = U.defVal(opts, {}); var elements = U.defVal(opts.elements, []); await this._checkImagesEquivalence(actualImage, expectedImage, opts); for (var element of elements) { var actualElImage = await this._cutElement( actualImage, element, { name: `actual ${element}` }); var expectedElImage = await this._cutElement( expectedImage, element, { name: `expected ${element}` }); await this._checkImagesEquivalence( actualElImage, expectedElImage, opts); }; }, /** * Step to check one image includes or doesn't include another image. * * @async * @method * @instance * @arg {string} fullImage - Path to image which may include. * @arg {string} includedImage - Path to image which may be included. * @arg {object} [opts] - Step options. * @arg {object} [opts.matchedDirPath] - Folder path to save matched image. * @arg {number} [opts.threshold=0.05] - Threshold of divergence. * @arg {boolean} [opts.shouldBe=true] - Flag to check whether * image are equal or not equal. * @return {Promise&lt;void&gt;} */ checkImageInclusion: async function (fullImage, includedImage, opts) { opts = U.defVal(opts, {}); var threshold = U.defVal(opts.threshold, 0.05); var shouldBe = U.defVal(opts.shouldBe, true); var matchedImagePath = U.mkpath( U.defVal( opts.matchedDirPath, path.resolve(getScreensDir(), &quot;inclusions&quot;)), uuid() + &quot;.png&quot;); var errMsg = &quot;Image &quot; + fullImage + &quot; doesn't contain image &quot; + includedImage; var result = await image(fullImage) .includes(includedImage, { tolerance: threshold, matchedPath: matchedImagePath }); if (shouldBe) { expect(result.isIncluded, `Image ${fullImage} doesn't include ${includedImage}`) .be.true; } else { expect(result.isIncluded, `Image ${fullImage} includes image ${includedImage}`) .be.false; }; }, /** * Step to check or make web screenshot in browser. * * @async * @method * @instance * @arg {string} imageName - Screenshot name. File extension * `.png` will be added automatically. * @arg {object} [opts] - Step options. * @arg {string} [opts.imageDirPath] - Screenshot folder path. * @arg {string} [opts.expectedDirPath] - Expected screenshot path. * @arg {boolean} [opts.bySelenium=true] - Flag to use selenium to make * screenshot. Other library `html2canvas` will be used. * @arg {?function} [opts.preHook=null] - Function which will be called * in `Steps` context in the beginning of step. * @arg {?function} [opts.postHook=null] - Function which will be called * in `Steps` context at the end of step. * @arg {string[]} [opts.elements=[]] - List of elements on image which * should be verified. * @arg {boolean} [opts.check=true] - Flag to check screenshot is saved * or no. * @return {Promise&lt;void&gt;} * @throws {AssertionError} - If screenshot isn't saved. */ checkOrMakeScreenshot: async function (imageName, opts) { imageName = kebab(imageName); opts = U.defVal(opts, {}); opts.imageName = imageName; var actualImage = await this.makeScreenshot(opts); if (CONF.compareImages) { testName = CONF.curTestCase ? kebab(CONF.curTestCase.name) : &quot;&quot;; var expectedImage = path.resolve( U.defVal( opts.expectedDirPath, path.resolve(CONF.resourcesDir, testName, &quot;screenshots&quot;)), imageName + &quot;.png&quot;); await this.checkImagesEquivalence( actualImage, expectedImage, opts); }; }, /** * Helper to check two images are equal or not equal. * * @async * @method * @protected * @instance * @arg {string} actualImage - Path to actual image. * @arg {string} expectedImage - Path to expected image. * @arg {object} [opts] - Helper options. * @arg {string} [opts.diffDirPath] - Path to diffs folder. * @arg {number} [opts.threshold=0.05] - Threshold of divergence. * @arg {boolean} [opts.shouldBe=true] - Flag to check whether * image are equal or not equal. * @return {Promise&lt;void&gt;} * @throws {AssertionError} - If actual image doesn't exist. * @throws {AssertionError} - If expected image doesn't exist. * @throws {AssertionError} - If result of images comparison don't pass * requested parameters. */ _checkImagesEquivalence: async function (actualImage, expectedImage, opts) { expect(fs.existsSync(actualImage), `Actual image '${actualImage}' doesn't exist`) .to.be.true; expect(fs.existsSync(expectedImage), `Expected image '${expectedImage}' doesn't exist`) .to.be.true; opts = U.defVal(opts, {}); var threshold = U.defVal(opts.threshold, 0.05); var shouldBe = U.defVal(opts.shouldBe, true); var diffImage = U.mkpath( U.defVal( opts.diffDirPath, path.resolve(getScreensDir(), &quot;diffs&quot;)), uuid() + &quot;.png&quot;); var percentage = (await new Promise((resolve, reject) =&gt; { imageDiff.getFullResult({ actualImage: actualImage, expectedImage: expectedImage, diffImage: diffImage }, function(err, result) { if (err) reject(err); resolve(result); }); })).percentage; if (shouldBe) { expect(percentage, &quot;Images are not equal&quot;).be.lte(threshold); } else { expect(percentage, &quot;Images are equal&quot;).be.gte(threshold); }; }, /** * Helper to make screenshot of display. * * @async * @method * @protected * @instance * @arg {string} imagePath - Path to screenshot which will be saved. * @return {Promise&lt;void&gt;} */ _displayScreenshot: async function (imagePath) { await new Promise((resolve, reject) =&gt; { this.__screenshot(imagePath, err =&gt; { if (err) return reject(err); resolve(); }); }); }, /** * Helper to make screenshot with selenium. * * @async * @method * @protected * @instance * @arg {string} imagePath - Path to screenshot which will be saved. * @return {Promise&lt;void&gt;} */ _seleniumScreenshot: async function (imagePath) { await this.webdriver.saveScreenshot(imagePath); }, /** * Helper to make screenshot with html2canvas. * * @async * @method * @protected * @instance * @arg {string} imagePath - Path to screenshot which will be saved. * @arg {object} [opts] - Helper options. * @arg {?string} [opts.cssSelector=null] - CSS selector of DOM element * which of screenshot should be made. * @arg {number} [opts.timeout=30000] - Time to wait for screenshot is * rendered, ms * @return {Promise&lt;void&gt;} * @throws {Error} - If screenshot will not be rendered during timeout. */ _canvasScreenshot: async function (imagePath, opts) { opts = U.defVal(opts, {}); var cssSelector = U.defVal(opts.cssSelector); var timeout = U.defVal(opts.timeout, 30000); var errMsg = &quot;Can't make screenshot&quot;; if (cssSelector) errMsg += &quot; of element with selector &quot; + cssSelector; await this.webdriver.execute(function (cssSelector) { function makeScreenshot () { if (cssSelector) { var element = document.querySelector(cssSelector); } else { var element = document.body; }; html2canvas( element, { onrendered: function(canvas) { window.__screenshot = canvas .toDataURL() .split(&quot;data:image/png;base64,&quot;)[1]; }, useCORS: true // capture images from another domains }); }; if (typeof(html2canvas) !== &quot;undefined&quot;) { makeScreenshot(); return; }; var script = document.createElement(&quot;script&quot;); script.onload = makeScreenshot; script.src = &quot;https://cdnjs.cloudflare.com&quot; + &quot;/ajax/libs/html2canvas/&quot; + &quot;0.5.0-beta4/html2canvas.min.js&quot;; document.body.appendChild(script); }, cssSelector); var screenBase64 = await this.webdriver.waitUntil(async () =&gt; { return (await this.webdriver.execute(function () { if (window.__screenshot) { var result = window.__screenshot; delete window.__screenshot; return result; } else { return false; }; })).value; }, timeout, errMsg); fs.writeFileSync(imagePath, screenBase64, &quot;base64&quot;); }, /** * Helper to cut element from image. * * @async * @method * @protected * @instance * @arg {string} imagePath - Path to image which element will be cut from. * @arg {string} elementName - Name of element which will be cut. * @arg {object} [opts] - Helper options. * @arg {string} [opts.name] - Name of cut image with element. * @arg {string} [opts.cutDirPath] - Folder path to cut elements. * @return {Promise&lt;string&gt;} - Path to cut element image. * @throws {AssertionError} - If original image doesn't exist. * @throws {AssertionError} - If DOM element is not registered in config. * @throws {AssertionError} - If cut image is not saved. */ _cutElement: async function (imagePath, elementName, opts) { expect(fs.existsSync(imagePath), `Image ${imagePath} doesn't exist`).be.true; var element = await this.getElement(elementName); opts = U.defVal(opts, {}); var targetName = U.defVal(opts.name, uuid()) + &quot;.png&quot;; var targetPath = U.mkpath( U.defVal( opts.cutDirPath, path.resolve(getScreensDir(), &quot;cutElements&quot;)), targetName); var imageInfo = await new Promise((resolve, reject) =&gt; { sharp(imagePath).toBuffer((err, outputBuffer, info) =&gt; { if (err) reject(err); resolve(info); }); }); var eLoc = await element.location(); if (eLoc.x &lt; 0) eLoc.x = 0; if (eLoc.y &lt; 0) eLoc.y = 0; if ((eLoc.x + eLoc.width) &gt; imageInfo.width) { eLoc.width = imageInfo.width - eLoc.x; }; if ((eLoc.y + eLoc.height) &gt; imageInfo.height) { eLoc.height = imageInfo.height - eLoc.y; }; if (imagePath === targetPath) { fs.renameSync(imagePath, imagePath + &quot;.tmp&quot;); imagePath += &quot;.tmp&quot;; }; await new Promise((resolve, reject) =&gt; { sharp(imagePath) .extract({ left: eLoc.x, top: eLoc.y, width: eLoc.width, height: eLoc.height }) .crop(sharp.strategy.entropy) .toFile(targetPath, err =&gt; { if (err) reject(err); resolve(); }); }); expect(fs.existsSync(targetPath, `Image ${targetPath} isn't saved`)).be.true; if (imagePath.endsWith(&quot;.tmp&quot;)) fs.unlinkSync(imagePath); return targetPath; }, }; module.exports = ImageSteps; /** * Helper to get screenshots folder. * * @ignore * @function */ var getScreensDir = () =&gt; { var testName = CONF.curTestCase ? kebab(CONF.curTestCase.name) : &quot;&quot;; return path.resolve(CONF.reportsDir, testName, &quot;screenshots&quot;); }; /** * Transform string to kebab style. * * @ignore * @function */ var kebab = string =&gt; string.trim().replace(/ +/g, '-').toLowerCase(); Ã— Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Source: index.js &quot;use strict&quot;; /** * `GlaceJS Image` plugin. * * @module */ var config, Steps; Object.defineProperties(exports, { /** * @type {GlaceConfig} */ config: { get: function() { config = config || require(&quot;./config&quot;); return config; }, }, /** * @type {ImageSteps} */ Steps: { get: function() { Steps = Steps || require(&quot;./steps&quot;); return Steps; }, }, }); Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Modules Classes Image Mixins ImageSteps Namespaces GlaceConfig Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Classes Classes Image Mixins ImageSteps Namespaces GlaceConfig Ã— Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Namespaces Classes Image Mixins ImageSteps Namespaces GlaceConfig Ã— Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Mixins Classes Image Mixins ImageSteps Namespaces GlaceConfig Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps GlaceJS Image pluginProvides steps for GlaceJS framework to process images and screenshots. Features Image capture via selenium Image capture via html2canvas Images comparision mechanism via ImageMagick Search image inside image via own pixel-by-pixel algorithm How to installnpm i glace-imageHow to usevar glaceImage = require(&quot;glace-image&quot;); glaceImage.Steps; glaceImage.config;If plugin is used as a part of GlaceJS it will be loaded automatically. API config steps Test examplesSee integration tests in order to explore examples. Ã— Search results Close "},"GlaceConfig.html":{"id":"GlaceConfig.html","title":"Namespace: GlaceConfig","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Namespace: GlaceConfig GlaceConfig Configures Image plugin. Extends GlaceJS configuration. Source: config.js, line 2 Ã— Search results Close "},"Image.html":{"id":"Image.html","title":"Class: Image","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Class: Image Image new Image(srcPath [, srcOpts]) Creates new instance of Image. Parameters: Name Type Argument Description srcPath string path to processed image srcOpts object &lt;optional&gt; image options Properties Name Type Argument Default Description scaleX number &lt;optional&gt; 1 image current scale value on X axis scaleY number &lt;optional&gt; 1 image current scale value on Y axis Source: image.js, line 2 Methods &lt;protected&gt; _cropPixels(pixels) Crops pixels, removes empty rows and columns. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 391 Returns: cropped pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; &lt;protected&gt; _cropTop(pixels) Crops top part of pixels matrix. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 412 Returns: cropped pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; &lt;protected&gt; _getDiffValue(srcPixels, dstPixels, offsetX, offsetY) Calculates difference between source pixels and destination pixels. Parameters: Name Type Description srcPixels Array.&lt;Array.&lt;object&gt;&gt; source pixels matrix dstPixels Array.&lt;Array.&lt;object&gt;&gt; destination pixels matrix offsetX number source left border offset offsetY number source top border offset Source: image.js, line 303 Returns: difference value Type number &lt;protected&gt; _getPixels(img) Retrieves pixels from image data. Parameters: Name Type Description img object image data Source: image.js, line 362 Returns: pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; &lt;protected&gt; _includes(src, dst) Defines whether one image data includes another. Parameters: Name Type Description src object source image data dst object destination image data, which is potentially included Source: image.js, line 244 Returns: result Type object &lt;protected&gt; _isPixelTolerant(srcPixel, dstPixel) Defines whether source pixel is tolerant to destination pixel. Parameters: Name Type Description srcPixel object source pixel dstPixel object destination pixel Source: image.js, line 344 Returns: true if pixels are tolerant, false otherwise Type boolean &lt;protected&gt; _isPixelUsed(pixel) Defines whether pixel should be used for difference calculation or no, according its alpha value. Parameters: Name Type Description pixel object pixel Source: image.js, line 332 Returns: true if should be, false otherwise Type boolean &lt;protected&gt; _loadImg(imgPath, imgOpts) Loads image. Parameters: Name Type Description imgPath string path loaded image imgOpts object image options Source: image.js, line 202 Returns: image data Type Promise.&lt;object&gt; &lt;protected&gt; _saveMatchImage(left, top, width, height) Saves matched part of image. Parameters: Name Type Description left number offset from left image border top number offset from top image border width number width of matched part height number height of matched part Source: image.js, line 230 Returns: Type Promise _transpose(pixels) Transposes pixels matrix. Parameters: Name Type Description pixels Array.&lt;Array.&lt;object&gt;&gt; pixels matrix Source: image.js, line 444 Returns: transposed pixels matrix Type Array.&lt;Array.&lt;object&gt;&gt; includes(dstPath [, dstOpts]) Defines if processed image includes specified image. Parameters: Name Type Argument Description dstPath string path to potentially included image dstOpts object &lt;optional&gt; included image options Properties Name Type Argument Default Description tolerance number &lt;optional&gt; 0.05 comparison tolerance matchedPath string &lt;optional&gt; &lt;nullable&gt; null path to same captured place saveMatch boolean &lt;optional&gt; false flag to capture images intersection or no Source: image.js, line 154 Returns: result Type Promise.&lt;object&gt; &lt;async&gt; isBlack() Defines whether processed image is black. Source: image.js, line 93 Returns: true if image is black, false otherwise. Type Promise.&lt;boolean&gt; &lt;async&gt; isMonochrome() Defines whether processed image is monochrome. Source: image.js, line 63 Returns: true if image is monochrome, false otherwise. Type Promise.&lt;boolean&gt; &lt;async&gt; isTransparent() Defines whether processed image is transparent. Source: image.js, line 39 Returns: true if image is transparent, false otherwise. Type Promise.&lt;boolean&gt; &lt;async&gt; isWhite() Defines whether processed image is white. Source: image.js, line 121 Returns: true if image is white, false otherwise. Type Promise.&lt;boolean&gt; Ã— Search results Close "},"ImageSteps.html":{"id":"ImageSteps.html","title":"Mixin: ImageSteps","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Mixin: ImageSteps ImageSteps Steps to manage screenshots and images. Source: steps.js, line 2 Members &lt;static&gt; __screenshot Used imports. Source: steps.js, line 26 Methods &lt;async, protected&gt; _canvasScreenshot(imagePath [, opts]) Helper to make screenshot with html2canvas. Parameters: Name Type Argument Description imagePath string Path to screenshot which will be saved. opts object &lt;optional&gt; Helper options. Properties Name Type Argument Default Description cssSelector string &lt;optional&gt; &lt;nullable&gt; null CSS selector of DOM element which of screenshot should be made. timeout number &lt;optional&gt; 30000 Time to wait for screenshot is rendered, ms Source: steps.js, line 332 Throws: If screenshot will not be rendered during timeout. Type Error Returns: Type Promise.&lt;void&gt; &lt;async, protected&gt; _checkImagesEquivalence(actualImage, expectedImage [, opts]) Helper to check two images are equal or not equal. Parameters: Name Type Argument Description actualImage string Path to actual image. expectedImage string Path to expected image. opts object &lt;optional&gt; Helper options. Properties Name Type Argument Default Description diffDirPath string &lt;optional&gt; Path to diffs folder. threshold number &lt;optional&gt; 0.05 Threshold of divergence. shouldBe boolean &lt;optional&gt; true Flag to check whether image are equal or not equal. Source: steps.js, line 244 Throws: If actual image doesn't exist. Type AssertionError If expected image doesn't exist. Type AssertionError If result of images comparison don't pass requested parameters. Type AssertionError Returns: Type Promise.&lt;void&gt; &lt;async, protected&gt; _cutElement(imagePath, elementName [, opts]) Helper to cut element from image. Parameters: Name Type Argument Description imagePath string Path to image which element will be cut from. elementName string Name of element which will be cut. opts object &lt;optional&gt; Helper options. Properties Name Type Argument Description name string &lt;optional&gt; Name of cut image with element. cutDirPath string &lt;optional&gt; Folder path to cut elements. Source: steps.js, line 410 Throws: If original image doesn't exist. Type AssertionError If DOM element is not registered in config. Type AssertionError If cut image is not saved. Type AssertionError Returns: Path to cut element image. Type Promise.&lt;string&gt; &lt;async, protected&gt; _displayScreenshot(imagePath) Helper to make screenshot of display. Parameters: Name Type Description imagePath string Path to screenshot which will be saved. Source: steps.js, line 295 Returns: Type Promise.&lt;void&gt; &lt;async, protected&gt; _seleniumScreenshot(imagePath) Helper to make screenshot with selenium. Parameters: Name Type Description imagePath string Path to screenshot which will be saved. Source: steps.js, line 313 Returns: Type Promise.&lt;void&gt; &lt;async&gt; checkImageInclusion(fullImage, includedImage [, opts]) Step to check one image includes or doesn't include another image. Parameters: Name Type Argument Description fullImage string Path to image which may include. includedImage string Path to image which may be included. opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description matchedDirPath object &lt;optional&gt; Folder path to save matched image. threshold number &lt;optional&gt; 0.05 Threshold of divergence. shouldBe boolean &lt;optional&gt; true Flag to check whether image are equal or not equal. Source: steps.js, line 151 Returns: Type Promise.&lt;void&gt; &lt;async&gt; checkImagesEquivalence(actualImage, expectedImage [, opts]) Step to check two image are equal or not equal Parameters: Name Type Argument Description actualImage string Path to actual image. expectedImage string Path to expected image. opts object &lt;optional&gt; Helper options. Properties Name Type Argument Default Description threshold number &lt;optional&gt; 0.05 Threshold of divergence. shouldBe boolean &lt;optional&gt; true Flag to check whether image are equal or not equal. elements Array.&lt;string&gt; &lt;optional&gt; [] List of elements on image which should be verified. Source: steps.js, line 122 Throws: If result of images comparison don't pass requested parameters. Type AssertionError Returns: Type Promise.&lt;void&gt; &lt;async&gt; checkOrMakeScreenshot(imageName [, opts]) Step to check or make web screenshot in browser. Parameters: Name Type Argument Description imageName string Screenshot name. File extension .png will be added automatically. opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description imageDirPath string &lt;optional&gt; Screenshot folder path. expectedDirPath string &lt;optional&gt; Expected screenshot path. bySelenium boolean &lt;optional&gt; true Flag to use selenium to make screenshot. Other library html2canvas will be used. preHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context in the beginning of step. postHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context at the end of step. elements Array.&lt;string&gt; &lt;optional&gt; [] List of elements on image which should be verified. check boolean &lt;optional&gt; true Flag to check screenshot is saved or no. Source: steps.js, line 204 Throws: If screenshot isn't saved. Type AssertionError Returns: Type Promise.&lt;void&gt; &lt;async&gt; makeScreenshot( [opts]) Step to make web screenshot in browser. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description imageName string &lt;optional&gt; Screenshot name. File extension .png will be added automatically. Default value is dynamically generated on each call with algorithm uuid. imageDirPath string &lt;optional&gt; Screenshot folder path. by boolean &lt;optional&gt; selenium Screenshot variant. Supported values are &quot;selenium&quot;, &quot;html2canvas&quot;, &quot;system&quot;. cssSelector string &lt;optional&gt; &lt;nullable&gt; null CSS selector of DOM element which of screenshot should be made. preHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context in the beginning of step. postHook function &lt;optional&gt; &lt;nullable&gt; null Function which will be called in Steps context at the end of step. element string &lt;optional&gt; &lt;nullable&gt; null Web element name which should be screenshotted. check boolean &lt;optional&gt; true Flag to check screenshot is saved or no. Source: steps.js, line 53 Throws: If screenshot isn't saved. Type AssertionError Returns: Path to saved screenshot. Type Promise.&lt;string&gt; Ã— Search results Close "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" GlaseJS Namespaces GlaceConfig Modules index Classes Image Mixins ImageSteps Module: index GlaceJS Image plugin. Source: index.js, line 2 Members &lt;inner&gt; config :GlaceConfig Type: GlaceConfig Source: index.js, line 14 &lt;inner&gt; Steps :ImageSteps Type: ImageSteps Source: index.js, line 23 Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
